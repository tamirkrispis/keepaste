Index: logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.utils;\r\n\r\nimport lombok.Setter;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport java.awt.*;\r\nimport java.awt.event.KeyEvent;\r\n\r\n/**\r\n * This class is a utility class for anything related to simulating keyboard clicks.\r\n */\r\n@Log4j2\r\npublic final class KeyboardUtils {\r\n    static final Robot ROBOT;\r\n\r\n    @Setter\r\n    static int delay = 50;\r\n\r\n    private KeyboardUtils() {\r\n        // private constructor for utils class\r\n    }\r\n\r\n    static {\r\n        try {\r\n            ROBOT = new Robot();\r\n            ROBOT.setAutoWaitForIdle(true);\r\n        } catch (AWTException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Imitate pressing the 'Enter' key.\r\n     */\r\n    public static void enter() {\r\n        log.debug(\"Robot pressing ENTER\");\r\n        ROBOT.keyPress(KeyEvent.VK_ENTER);\r\n        ROBOT.keyRelease(KeyEvent.VK_ENTER);\r\n    }\r\n\r\n    /**\r\n     * Imitate pressing a keyboard key.\r\n     *\r\n     * @param keyEventCode the key code of the keyboard button\r\n     */\r\n    public static void keyPress(final int keyEventCode) {\r\n        ROBOT.keyPress(keyEventCode);\r\n    }\r\n\r\n    /**\r\n     * Imitate releasing a keyboard key.\r\n     *\r\n     * @param keyEventCode the key code of the keyboard button\r\n     */\r\n    public static void keyRelease(final int keyEventCode) {\r\n        ROBOT.keyRelease(keyEventCode);\r\n    }\r\n\r\n    /**\r\n     * Perform a delay between key strokes.\r\n     *\r\n     * @param ms the time interval in ms to delay.\r\n     */\r\n    public static void delay(final int ms) {\r\n        ROBOT.delay(ms);\r\n    }\r\n\r\n    public static void cmdV() {\r\n        // VK_META is problematic on Mac, so this is a hack for pressing it for several times, then releasing it, so at least one will be simulated\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.delay(50);\r\n        ROBOT.keyPress(KeyEvent.VK_V);\r\n        ROBOT.delay(50);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_V);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java b/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java
--- a/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java	(revision 6b388e737d259f725c36eacdeab1821d3f311995)
+++ b/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java	(date 1698616161020)
@@ -18,6 +18,7 @@
 
 package com.keepaste.logic.utils;
 
+import com.keepaste.logic.exceptions.KeepasteGenericException;
 import lombok.Setter;
 import lombok.extern.log4j.Log4j2;
 import java.awt.*;
@@ -28,10 +29,8 @@
  */
 @Log4j2
 public final class KeyboardUtils {
-    static final Robot ROBOT;
-
-    @Setter
-    static int delay = 50;
+    private static final Robot ROBOT;
+    public static final int ROBOT_DELAY_IN_MS = 50;
 
     private KeyboardUtils() {
         // private constructor for utils class
@@ -42,7 +41,7 @@
             ROBOT = new Robot();
             ROBOT.setAutoWaitForIdle(true);
         } catch (AWTException e) {
-            throw new RuntimeException(e);
+            throw new KeepasteGenericException("Failed to initialize Robot class", e);
         }
     }
 
@@ -82,21 +81,4 @@
         ROBOT.delay(ms);
     }
 
-    public static void cmdV() {
-        // VK_META is problematic on Mac, so this is a hack for pressing it for several times, then releasing it, so at least one will be simulated
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.delay(50);
-        ROBOT.keyPress(KeyEvent.VK_V);
-        ROBOT.delay(50);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_V);
-    }
 }
Index: logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.keepaste.logic.managers;\r\n\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.models.Keep;\r\nimport com.keepaste.logic.models.KeepParameter;\r\nimport com.keepaste.logic.models.WindowInformation;\r\nimport com.keepaste.logic.utils.ClipboardUtils;\r\nimport com.keepaste.logic.utils.FileSystemUtils;\r\nimport com.keepaste.logic.utils.KeyboardUtils;\r\nimport com.keepaste.logic.utils.OperatingSystemUtils;\r\nimport lombok.Getter;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport javax.swing.*;\r\nimport java.awt.event.KeyListener;\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.stream.Collectors;\r\nimport static com.keepaste.logic.common.Constants.ONLY_COPY_MODE;\r\n\r\n/**\r\n * This class hods methods related to Keep execution.\r\n */\r\n@Log4j2\r\npublic final class KeepExecutionManager {\r\n    public static final String FAILED_TO_EXECUTE_KEEP = \"Failed to execute keep\";\r\n    @Getter\r\n    private static final Map<String, String> globalParameterValuesMap = new HashMap<>();\r\n\r\n    private String shell = \"/bin/bash\";\r\n\r\n    public KeepExecutionManager() throws Exception {\r\n        if (OperatingSystemUtils.getOperatingSystemType() != OperatingSystemUtils.OperatingSystemType.WINDOWS) {\r\n            List<String> shellValue = executeCommandWithDefaultPath(\"echo $SHELL\");\r\n            if (!shellValue.isEmpty()) {\r\n                shell = shellValue.get(0);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Executed a selected {@link Keep} on the currently active window.\r\n     *\r\n     * @param keep the {@link Keep} to execute\r\n     */\r\n    public void executeKeepOnWindow(Keep keep) {\r\n        executeKeepOnWindow(keep, false);\r\n    }\r\n\r\n    /**\r\n     * Executed a selected {@link Keep} on the currently active window.\r\n     *\r\n     * @param keep the {@link Keep} to execute\r\n     * @param refreshParameters true if we wish to clear the existing global parameters and have a fresh start\r\n     */\r\n    public void executeKeepOnWindow(Keep keep, boolean refreshParameters) {\r\n        log.info(\r\n                \"Executing Keep [{}] on window [{}] with refresh parameters [{}]\",\r\n                keep.toStringAll(), Application.getContext().getModelActiveWindow(), refreshParameters);\r\n\r\n        // stopping window interception while running the Keep to prevent pasting on wrong window\r\n        Application.getContext().stopWindowInterceptorRunner();\r\n\r\n        // keeping the active window that the user meant to paste on\r\n        WindowInformation currentlyActiveWindow = Application.getContext().getModelActiveWindow().getActiveWindow();\r\n\r\n        // validating that only one keep is running at a time\r\n        if (Application.getContext().isKeepCurrentlyRunning()) {\r\n            JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                    \"Can only run one Keep at a time, please wait for the other Keep to finish or abort it\",\r\n                    \"One Keep at a time please\", JOptionPane.WARNING_MESSAGE);\r\n            return;\r\n        }\r\n\r\n        Application.getContext().setKeepCurrentlyRunning(true);\r\n\r\n        // preventing from enter being pressed on dialogs shown while manipulating parameters from triggering the tree's\r\n        // key listener (prevents from running another keep by mistake when pressing ENTER)\r\n        Optional<KeyListener> viewTreeKeyListener =\r\n                Arrays.stream(Application.getContext().getGui().tree.getKeyListeners())\r\n                        .filter(keyListener -> keyListener.getClass().getName().contains(\"ViewTree\"))\r\n                        .findFirst();\r\n        viewTreeKeyListener.ifPresent(keyListener -> Application.getContext().getGui().tree.removeKeyListener(keyListener));\r\n\r\n        Application.getContext().getGui().labelBackground.setText(\"Executing keep...\");\r\n        Application.getContext().getGui().labelBackground.setVisible(true);\r\n        SwingWorker<Void, String> worker = new SwingWorker<>() {\r\n            @Override\r\n            protected Void doInBackground() throws InterruptedException {\r\n                try {\r\n                    String keepToExecute = manipulateParameters(keep, refreshParameters);\r\n                    log.info(\"Final Keep to execute [{}]\", keepToExecute);\r\n                    if (!StringUtils.isEmpty(keepToExecute)) {\r\n                        log.debug(\"Setting [{}] to clipboard\", keepToExecute);\r\n                        ClipboardUtils.setValue(keepToExecute);\r\n                        if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {\r\n                            new Thread(() -> {\r\n                                Application.getContext().getGui().labelTargetWindow.setText(\"Keep copied, ready to paste...\");\r\n                                try {\r\n                                    Thread.sleep(1000);\r\n                                } catch (InterruptedException e) {\r\n                                    log.error(\"Sleep interrupted exception\", e);\r\n                                    Thread.currentThread().interrupt();\r\n                                }\r\n                                Application.getContext().getGui().labelTargetWindow.setText(ONLY_COPY_MODE);\r\n                            }).start();\r\n                        } else {\r\n                            if (Application.getContext().getWindowManager().focusOnActiveWindow(currentlyActiveWindow)) {\r\n                                if (Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {\r\n                                    log.debug(\"pasting \".concat(ClipboardUtils.getValue().toString()));\r\n                                    Application.getContext().getWindowManager().paste();\r\n                                }\r\n\r\n                                if (Application.getContext().getModelSettings().isPressEnterAfterPaste()) {\r\n                                    if (keep.isNeverPressEnter()) {\r\n                                        log.debug(\"keep is set to never press 'enter' so it didn't\");\r\n                                    } else {\r\n                                        log.debug(\"Imitating \\\"ENTER\\\" key\");\r\n                                        KeyboardUtils.enter();\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                                        \"Seems like keepaste is not focused on the desired window, please try again...\",\r\n                                        \"Warning\",\r\n                                        JOptionPane.WARNING_MESSAGE);\r\n                                log.debug(\"Not focused on correct window so not pasting and pressing ENTER\");\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                            FAILED_TO_EXECUTE_KEEP,\r\n                            \"Bummer...\",\r\n                            JOptionPane.ERROR_MESSAGE);\r\n                    log.error(FAILED_TO_EXECUTE_KEEP, e);\r\n                    throw e;\r\n                }\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n            protected void done() {\r\n                Application.getContext().getGui().labelBackground.setVisible(false);\r\n                Application.getContext().setKeepCurrentlyRunning(false);\r\n\r\n                viewTreeKeyListener.ifPresent(keyListener -> Application.getContext().getGui().tree.addKeyListener(keyListener));\r\n\r\n                Application.getContext().setKeepCurrentlyRunning(false);\r\n                Application.getContext().startWindowInterceptorRunner();\r\n\r\n                log.debug(\"Keep execution finished\");\r\n            }\r\n        };\r\n        worker.execute();\r\n\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param command the command to execute\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommandWithDefaultPath(String command) throws Exception {\r\n        return executeCommand(List.of(command), true);\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param command the command to execute\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommand(String command) throws Exception {\r\n        return executeCommand(List.of(command), false);\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param commandLines  the command lines to execute\r\n     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal commands (like intercepting the currently active window)\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommand(List<String> commandLines, boolean defaultPath) throws Exception {\r\n        ProcessBuilder processBuilder = new ProcessBuilder();\r\n        // Set the working directory for the process\r\n        processBuilder.directory(new File(FileSystemUtils.getUserHomeDirectory()));\r\n\r\n        List<String> newKeep = new ArrayList<>();\r\n\r\n        OperatingSystemUtils.OperatingSystemType os = OperatingSystemUtils.getOperatingSystemType();\r\n        switch (os.name()) {\r\n            case OperatingSystemUtils.WINDOWS:\r\n//                newKeep.add(\"cmd.exe\");\r\n//                newKeep.add(\"/c\");\r\n//                newKeep.addAll(commandLines);\r\n//                processBuilder.command(newKeep);\r\n\r\n                newKeep.add(\"powershell.exe\");\r\n                newKeep.add(\"-Command\");\r\n                newKeep.addAll(commandLines);\r\n                processBuilder.command(newKeep);\r\n                break;\r\n            case OperatingSystemUtils.MAC:\r\n            case OperatingSystemUtils.LINUX:\r\n            case OperatingSystemUtils.OTHER:\r\n            default:\r\n                if (!defaultPath) {\r\n                    // Get the environment variables\r\n                    Map<String, String> environment = processBuilder.environment();\r\n                    environment.put(\"PATH\", Application.getContext().getModelSettings().getPath());\r\n                }\r\n\r\n                newKeep.add(shell);\r\n                newKeep.add(\"-c\");\r\n                newKeep.addAll(commandLines);\r\n                processBuilder.command(newKeep);\r\n                break;\r\n        }\r\n        processBuilder.redirectErrorStream(true);\r\n        Process process = processBuilder.start();\r\n\r\n        InputStream inputStream = process.getInputStream();\r\n\r\n        BufferedReader reader =\r\n                new BufferedReader(new InputStreamReader(inputStream));\r\n\r\n        int timeout = 10;\r\n        do {\r\n            timeout--;\r\n            process.waitFor(1, TimeUnit.SECONDS);\r\n        } while (process.isAlive() && timeout > 0);\r\n\r\n        if (timeout <= 0) {\r\n            throw new RuntimeException(\"Command timeout exceeded (10 sec.)\");\r\n        }\r\n\r\n        String line;\r\n        List<String> outputLines = new ArrayList<>();\r\n        if (inputStream.available() > 0) {\r\n            while ((line = reader.readLine()) != null) {\r\n                outputLines.add(line);\r\n            }\r\n        }\r\n        inputStream.close();\r\n        return outputLines;\r\n    }\r\n\r\n    /**\r\n     * Will manage a Keep parameter.\r\n     *\r\n     * @param parameter                 the {@link KeepParameter} to handle\r\n     * @param keep                      the {@link Keep} in context\r\n     * @param refreshParameters         if to refresh the global parameters\r\n     * @param currentParameterValuesMap the current global parameters cache\r\n     * @throws IOException\r\n     * @throws InterruptedException\r\n     */\r\n    private void executeParameter(\r\n            KeepParameter parameter,\r\n            Keep keep,\r\n            boolean refreshParameters,\r\n            Map<String, String> currentParameterValuesMap) throws Exception {\r\n        String selectedParamValue = null;\r\n        // checking if we already have a value for this parameter (unless refresh parameters was chosen)\r\n        if (!refreshParameters && parameter.isGlobal() && globalParameterValuesMap.containsKey(parameter.getName())) {\r\n            selectedParamValue = globalParameterValuesMap.get(parameter.getName());\r\n            currentParameterValuesMap.put(parameter.getName(), selectedParamValue);\r\n            log.debug(\"Parameter [{}] was taken from global parameters, selected value=[{}]\", parameter, selectedParamValue);\r\n        } else if (!currentParameterValuesMap.containsKey(parameter.getName())) {\r\n            if (parameter.getPhrase() != null && !parameter.getPhrase().isEmpty()) {\r\n                List<String> keepResult = null;\r\n\r\n                // Keep parameter\r\n                String paramKeepString = parameter.getPhrase();\r\n\r\n                // filling existing parameters values if already chosen and used in the next parameter\r\n                for (Map.Entry<String, String> currParam : currentParameterValuesMap.entrySet()) {\r\n                    if (currentParameterValuesMap.containsKey(currParam.getKey())) {\r\n                        paramKeepString = paramKeepString.replace(String.format(\"<%s>\", currParam.getKey()), currParam.getValue());\r\n                        log.debug(\"Parameter [{}] was taken from current run parameters, selected value=[{}]\", parameter, currParam.getValue());\r\n                    }\r\n                }\r\n\r\n                if (parameter.getPhrase().startsWith(\"[\")) {\r\n                    // predefined array of values\r\n                    keepResult = Arrays.stream(parameter.getPhrase().substring(1, parameter.getPhrase().length() - 1)\r\n                                    .split(\",\")).map(String::trim)\r\n                            .collect(Collectors.toList());\r\n                    log.debug(\"Parameter [{}] is of array type, values=[{}]\", parameter, keepResult);\r\n                } else {\r\n                    if (!StringUtils.isEmpty(paramKeepString)) {\r\n                        try {\r\n                            log.debug(\"Parameter [{}] is of Command type, executing param command [{}]\", parameter, paramKeepString);\r\n\r\n                            // checking if the param Keep uses parameters as well, and if so, executing those first\r\n                            for (KeepParameter innerParameter : keep.getParameters()) {\r\n                                if (paramKeepString.contains(String.format(\"<%s>\", innerParameter.getName()))) {\r\n                                    // this parameter uses another one, so executing it first\r\n                                    executeParameter(innerParameter, keep, refreshParameters, currentParameterValuesMap);\r\n                                    paramKeepString = paramKeepString.replace(\r\n                                            String.format(\"<%s>\", innerParameter.getName()),\r\n                                            currentParameterValuesMap.get(innerParameter.getName()));\r\n                                }\r\n                            }\r\n\r\n                            keepResult = executeCommand(paramKeepString);\r\n                            log.debug(\"Parameter [{}], Keep result=[{}]\", parameter, keepResult);\r\n                        } catch (InterruptedException e) {\r\n                            Thread.currentThread().interrupt();\r\n                        } catch (Exception e) {\r\n                            JOptionPane.showMessageDialog(\r\n                                    Application.getContext().getGui().getContentPane(),\r\n                                    String.format(\r\n                                            \"Failed to run Keep \\\"%s\\\" for parameter \\\"%s\\\". %s.\",\r\n                                            parameter.getPhrase(), parameter.getName(), e.getMessage()),\r\n                                    \"Error when running a Keep\",\r\n                                    JOptionPane.ERROR_MESSAGE\r\n                            );\r\n                            throw e;\r\n                        }\r\n                    }\r\n                }\r\n                if (keepResult != null) {\r\n                    log.debug(\"Showing the user a dialog to choose a value for tha parameter [{}]\", parameter);\r\n                    selectedParamValue = (String) JOptionPane.showInputDialog(\r\n                            Application.getContext().getGui().getContentPane(),\r\n                            String.format(\"Choose a value for %s\", parameter.getName()),\r\n                            \"Set parameter value\",\r\n                            JOptionPane.QUESTION_MESSAGE,\r\n                            null,\r\n                            parseToLineByLine(keepResult),\r\n                            null);\r\n                    log.debug(\"User selected the value [{}] for parameter [{}]\", selectedParamValue, parameter);\r\n                    if (StringUtils.isEmpty(selectedParamValue)) {\r\n                        JOptionPane.showMessageDialog(\r\n                                Application.getContext().getGui(),\r\n                                String.format(\r\n                                        \"Value for parameter \\\"%s\\\" is not set, cancelling processing the Keep\",\r\n                                        parameter.getName())\r\n                        );\r\n                        log.debug(\r\n                                \"The user probably clicked on the cancel button on the dialog to choose a value \"\r\n                                        + \"for the parameter [{}]\", parameter);\r\n                        throw new RuntimeException(\"User cancelled\");\r\n                    }\r\n                }\r\n            } else {\r\n                log.debug(\"Parameter [{}] is of a free-text type\", parameter);\r\n                // free text parameter\r\n                selectedParamValue = JOptionPane.showInputDialog(\r\n                        Application.getContext().getGui().getContentPane(),\r\n                        String.format(\"Input a value for %s\", parameter.getName()),\r\n                        \"Set parameter value\",\r\n                        JOptionPane.QUESTION_MESSAGE);\r\n                log.debug(\"Value of [{}] was set to free-text parameter [{}]\", selectedParamValue, parameter);\r\n            }\r\n\r\n            if (StringUtils.isEmpty(selectedParamValue)) {\r\n                JOptionPane.showMessageDialog(\r\n                        Application.getContext().getGui(),\r\n                        String.format(\"Value for parameter \\\"%s\\\" is not set, cancelling processing the Keep\",\r\n                                parameter.getName())\r\n                );\r\n                log.debug(\r\n                        \"The user probably clicked on the cancel button on the dialog to set a free-text for \"\r\n                                + \"the parameter [{}]\", parameter);\r\n                throw new RuntimeException(\"User cancelled\");\r\n            } else {\r\n                if (keep.getPhrase() != null && !StringUtils.isEmpty(selectedParamValue)) {\r\n                    log.debug(\"Adding value of [{} for parameter [{}] to the current parameters values map\", selectedParamValue, parameter);\r\n                    currentParameterValuesMap.put(parameter.getName(), selectedParamValue);\r\n                    if (parameter.isGlobal()) {\r\n                        log.debug(\r\n                                \"As it is set to be global, adding value of [{}] for parameter [{}] to the global \"\r\n                                        + \"parameters values map\", selectedParamValue, parameter);\r\n                        globalParameterValuesMap.put(parameter.getName(), selectedParamValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /* ***************** PRIVATE METHODS ***************** */\r\n\r\n    private String manipulateParameters(Keep keep, boolean refreshParameters) {\r\n        log.debug(\"Manipulating parameters\");\r\n        // manipulating parameters\r\n\r\n        String keepToExecute = keep.getPhrase();\r\n        Map<String, String> currentParameterValuesMap = new HashMap<>();\r\n        if (keep.getParameters() != null && !keep.getParameters().isEmpty()) {\r\n            for (KeepParameter parameter : keep.getParameters()) {\r\n                log.debug(\"Manipulating parameter [{}]\", parameter);\r\n\r\n                try {\r\n                    executeParameter(parameter, keep, refreshParameters, currentParameterValuesMap);\r\n                } catch (InterruptedException ex) {\r\n                    log.error(FAILED_TO_EXECUTE_KEEP, ex);\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n                catch (Exception ex) {\r\n                    log.error(FAILED_TO_EXECUTE_KEEP, ex);\r\n                    return null; // cancelling\r\n                }\r\n            }\r\n\r\n            for (Map.Entry<String, String> entry : currentParameterValuesMap.entrySet()) {\r\n                keepToExecute = keepToExecute.replace(String.format(\"<%s>\", entry.getKey()), entry.getValue());\r\n            }\r\n        }\r\n\r\n        return keepToExecute;\r\n    }\r\n\r\n    private String[] parseToLineByLine(List<String> stringToParse) {\r\n        if (stringToParse.size() == 1 && stringToParse.get(0).startsWith(\"[\") && stringToParse.get(0).endsWith(\"]\")) {\r\n            // this is a one-liner json array, splitting it, the next 'if' statement will process it\r\n            String jsonArr = stringToParse.get(0);\r\n            jsonArr = jsonArr.substring(1, jsonArr.length() - 1);\r\n            stringToParse = Arrays.asList(jsonArr.split(\",\"));\r\n        }\r\n\r\n        if (!stringToParse.isEmpty() && stringToParse.get(0).equals(\"[\")) {\r\n            // in case of a json array, an option to return visible and actual values for the dropdown lists (name of ec2 instance to display, the id to use on the command)\r\n            // parse from a json array\r\n            stringToParse.remove(0); // the opening '['\r\n            stringToParse.remove(stringToParse.size() - 1); // the closing ']'\r\n            stringToParse.replaceAll(s -> s.replace(\"\\\",\", \"\").replace(\"\\\"\", \"\").trim()); // removing \", and \"\r\n        }\r\n\r\n        Collections.sort(stringToParse);\r\n\r\n        return stringToParse.toArray(new String[stringToParse.size()]);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java b/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java
--- a/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java	(revision 6b388e737d259f725c36eacdeab1821d3f311995)
+++ b/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java	(date 1698616363296)
@@ -1,6 +1,8 @@
 package com.keepaste.logic.managers;
 
 import com.keepaste.logic.Application;
+import com.keepaste.logic.exceptions.KeepExecutionException;
+import com.keepaste.logic.exceptions.KeepParameterExecutionException;
 import com.keepaste.logic.models.Keep;
 import com.keepaste.logic.models.KeepParameter;
 import com.keepaste.logic.models.WindowInformation;
@@ -9,6 +11,7 @@
 import com.keepaste.logic.utils.KeyboardUtils;
 import com.keepaste.logic.utils.OperatingSystemUtils;
 import lombok.Getter;
+import lombok.NonNull;
 import lombok.extern.log4j.Log4j2;
 import org.apache.commons.lang3.StringUtils;
 import javax.swing.*;
@@ -36,15 +39,30 @@
 public final class KeepExecutionManager {
     public static final String FAILED_TO_EXECUTE_KEEP = "Failed to execute keep";
     @Getter
-    private static final Map<String, String> globalParameterValuesMap = new HashMap<>();
+    private static final Map<String, String> GLOBAL_PARAMETER_VALUES_MAP = new HashMap<>();
+    public static final int COMMAND_EXEC_TIMEOUT = 15;
 
     private String shell = "/bin/bash";
 
-    public KeepExecutionManager() throws Exception {
+    /**
+     * Constructor.
+     *
+     * @throws IOException          on error
+     * @throws InterruptedException on error
+     */
+    public KeepExecutionManager() {
         if (OperatingSystemUtils.getOperatingSystemType() != OperatingSystemUtils.OperatingSystemType.WINDOWS) {
-            List<String> shellValue = executeCommandWithDefaultPath("echo $SHELL");
-            if (!shellValue.isEmpty()) {
-                shell = shellValue.get(0);
+            try {
+                List<String> shellValue = executeCommandWithDefaultPath("echo $SHELL");
+                if (!shellValue.isEmpty()) {
+                    shell = shellValue.get(0);
+                    log.debug("Shell set to [{}]", shell);
+                }
+            } catch (Exception ex) {
+                log.error(String.format("Failed to get shell, using default shell of [%s]", shell), ex);
+                if (ex instanceof InterruptedException) {
+                    Thread.currentThread().interrupt();
+                }
             }
         }
     }
@@ -70,6 +88,11 @@
                 "Executing Keep [{}] on window [{}] with refresh parameters [{}]",
                 keep.toStringAll(), Application.getContext().getModelActiveWindow(), refreshParameters);
 
+        // clearing selection from tree not to accidentally executing the selected node when the user presses the 'enter'
+        // key (like on dialogs)
+        var currentSelectionPath = Application.getContext().getGui().tree.getSelectionPath();
+        Application.getContext().getGui().tree.clearSelection();
+
         // stopping window interception while running the Keep to prevent pasting on wrong window
         Application.getContext().stopWindowInterceptorRunner();
 
@@ -98,55 +121,23 @@
         Application.getContext().getGui().labelBackground.setVisible(true);
         SwingWorker<Void, String> worker = new SwingWorker<>() {
             @Override
-            protected Void doInBackground() throws InterruptedException {
-                try {
-                    String keepToExecute = manipulateParameters(keep, refreshParameters);
-                    log.info("Final Keep to execute [{}]", keepToExecute);
-                    if (!StringUtils.isEmpty(keepToExecute)) {
-                        log.debug("Setting [{}] to clipboard", keepToExecute);
-                        ClipboardUtils.setValue(keepToExecute);
-                        if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
-                            new Thread(() -> {
-                                Application.getContext().getGui().labelTargetWindow.setText("Keep copied, ready to paste...");
-                                try {
-                                    Thread.sleep(1000);
-                                } catch (InterruptedException e) {
-                                    log.error("Sleep interrupted exception", e);
-                                    Thread.currentThread().interrupt();
-                                }
-                                Application.getContext().getGui().labelTargetWindow.setText(ONLY_COPY_MODE);
-                            }).start();
-                        } else {
-                            if (Application.getContext().getWindowManager().focusOnActiveWindow(currentlyActiveWindow)) {
-                                if (Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
-                                    log.debug("pasting ".concat(ClipboardUtils.getValue().toString()));
-                                    Application.getContext().getWindowManager().paste();
-                                }
-
-                                if (Application.getContext().getModelSettings().isPressEnterAfterPaste()) {
-                                    if (keep.isNeverPressEnter()) {
-                                        log.debug("keep is set to never press 'enter' so it didn't");
-                                    } else {
-                                        log.debug("Imitating \"ENTER\" key");
-                                        KeyboardUtils.enter();
-                                    }
-                                }
-                            } else {
-                                JOptionPane.showMessageDialog(Application.getContext().getGui(),
-                                        "Seems like keepaste is not focused on the desired window, please try again...",
-                                        "Warning",
-                                        JOptionPane.WARNING_MESSAGE);
-                                log.debug("Not focused on correct window so not pasting and pressing ENTER");
-                            }
+            protected Void doInBackground() {
+                String keepToExecute = manipulateParameters(keep, refreshParameters);
+                log.info("Final Keep to execute [{}]", keepToExecute);
+                if (!StringUtils.isEmpty(keepToExecute)) {
+
+                    copyToClipboard(keepToExecute);
+
+                    if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
+                        handleOnlyCopy();
+                    } else {
+                        if (isFocusOnActiveWindow(currentlyActiveWindow)) {
+                            pasteKeep();
+                            pressEnter(keep);
+                        } else {
+                            handleWrongTargetWindow();
                         }
                     }
-                } catch (Exception e) {
-                    JOptionPane.showMessageDialog(Application.getContext().getGui(),
-                            FAILED_TO_EXECUTE_KEEP,
-                            "Bummer...",
-                            JOptionPane.ERROR_MESSAGE);
-                    log.error(FAILED_TO_EXECUTE_KEEP, e);
-                    throw e;
                 }
                 return null;
             }
@@ -161,11 +152,55 @@
                 Application.getContext().setKeepCurrentlyRunning(false);
                 Application.getContext().startWindowInterceptorRunner();
 
+                Application.getContext().getGui().tree.setSelectionPath(currentSelectionPath);
+
                 log.debug("Keep execution finished");
             }
         };
         worker.execute();
+    }
+
+    private static void copyToClipboard(String keepToExecute) {
+        // setting final keep command to the clipboard
+        log.debug("Setting [{}] to clipboard", keepToExecute);
+        ClipboardUtils.setValue(keepToExecute);
+    }
+
+    private static void handleWrongTargetWindow() {
+        JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                "Seems like keepaste is not focused on the desired window, please try again...",
+                "Warning",
+                JOptionPane.WARNING_MESSAGE);
+        log.debug("Not focused on correct window so not pasting and pressing ENTER");
+    }
+
+    private static void pressEnter(Keep keep) {
+        if (Application.getContext().getModelSettings().isPressEnterAfterPaste()) {
+            if (keep.isNeverPressEnter()) {
+                log.debug("keep is set to never press 'enter' so it didn't");
+            } else {
+                log.debug("Imitating \"ENTER\" key");
+                KeyboardUtils.enter();
+            }
+        }
+    }
 
+    private static void pasteKeep() {
+        if (Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
+            log.debug("pasting ".concat(ClipboardUtils.getValue().toString()));
+            Application.getContext().getWindowManager().paste();
+        }
+    }
+
+    private static boolean isFocusOnActiveWindow(WindowInformation currentlyActiveWindow) {
+        if (currentlyActiveWindow == null) {
+            JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                    "Please select a window by clicking on it in order to run Keeps",
+                    "No active window", JOptionPane.WARNING_MESSAGE);
+            throw new KeepExecutionException("No active window is set");
+        } else {
+            return Application.getContext().getWindowManager().focusOnActiveWindow(currentlyActiveWindow);
+        }
     }
 
     /**
@@ -176,7 +211,7 @@
      * @throws IOException in case of execution failure
      * @throws InterruptedException in case of execution failure
      */
-    public List<String> executeCommandWithDefaultPath(String command) throws Exception {
+    public List<String> executeCommandWithDefaultPath(String command) throws KeepExecutionException, IOException, InterruptedException {
         return executeCommand(List.of(command), true);
     }
 
@@ -188,7 +223,7 @@
      * @throws IOException in case of execution failure
      * @throws InterruptedException in case of execution failure
      */
-    public List<String> executeCommand(String command) throws Exception {
+    public List<String> executeCommand(String command) throws KeepExecutionException, IOException, InterruptedException {
         return executeCommand(List.of(command), false);
     }
 
@@ -196,12 +231,14 @@
      * Will execute a command in shell and return its output as a list of Strings.
      *
      * @param commandLines  the command lines to execute
-     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal commands (like intercepting the currently active window)
+     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal
+     *                      commands (like intercepting the currently active window)
      * @return  the execution output
      * @throws IOException in case of execution failure
      * @throws InterruptedException in case of execution failure
      */
-    public List<String> executeCommand(List<String> commandLines, boolean defaultPath) throws Exception {
+    public List<String> executeCommand(List<String> commandLines, boolean defaultPath)
+            throws KeepExecutionException, IOException, InterruptedException {
         ProcessBuilder processBuilder = new ProcessBuilder();
         // Set the working directory for the process
         processBuilder.directory(new File(FileSystemUtils.getUserHomeDirectory()));
@@ -211,11 +248,6 @@
         OperatingSystemUtils.OperatingSystemType os = OperatingSystemUtils.getOperatingSystemType();
         switch (os.name()) {
             case OperatingSystemUtils.WINDOWS:
-//                newKeep.add("cmd.exe");
-//                newKeep.add("/c");
-//                newKeep.addAll(commandLines);
-//                processBuilder.command(newKeep);
-
                 newKeep.add("powershell.exe");
                 newKeep.add("-Command");
                 newKeep.addAll(commandLines);
@@ -245,14 +277,14 @@
         BufferedReader reader =
                 new BufferedReader(new InputStreamReader(inputStream));
 
-        int timeout = 10;
+        int timeout = COMMAND_EXEC_TIMEOUT;
         do {
             timeout--;
             process.waitFor(1, TimeUnit.SECONDS);
         } while (process.isAlive() && timeout > 0);
 
         if (timeout <= 0) {
-            throw new RuntimeException("Command timeout exceeded (10 sec.)");
+            throw new KeepExecutionException("Command timeout exceeded (10 sec.)");
         }
 
         String line;
@@ -271,134 +303,176 @@
      *
      * @param parameter                 the {@link KeepParameter} to handle
      * @param keep                      the {@link Keep} in context
-     * @param refreshParameters         if to refresh the global parameters
+     * @param isRefreshGlobalParameters         if to refresh the global parameters
      * @param currentParameterValuesMap the current global parameters cache
-     * @throws IOException
-     * @throws InterruptedException
+     * @throws Exception in case of any error
      */
     private void executeParameter(
-            KeepParameter parameter,
-            Keep keep,
-            boolean refreshParameters,
-            Map<String, String> currentParameterValuesMap) throws Exception {
-        String selectedParamValue = null;
-        // checking if we already have a value for this parameter (unless refresh parameters was chosen)
-        if (!refreshParameters && parameter.isGlobal() && globalParameterValuesMap.containsKey(parameter.getName())) {
-            selectedParamValue = globalParameterValuesMap.get(parameter.getName());
-            currentParameterValuesMap.put(parameter.getName(), selectedParamValue);
-            log.debug("Parameter [{}] was taken from global parameters, selected value=[{}]", parameter, selectedParamValue);
-        } else if (!currentParameterValuesMap.containsKey(parameter.getName())) {
-            if (parameter.getPhrase() != null && !parameter.getPhrase().isEmpty()) {
-                List<String> keepResult = null;
+            @NonNull final KeepParameter parameter,
+            @NonNull final Keep keep,
+            final boolean isRefreshGlobalParameters,
+            @NonNull final Map<String, String> currentParameterValuesMap) {
+
+        // in case of this is a global parameter, checking if the value already exist for it
+        validateValueSetForGlobalParam(parameter, currentParameterValuesMap, isRefreshGlobalParameters);
+
+        // in case the value doesn't exist yet
+        if (!ifParamValueSet(parameter, currentParameterValuesMap)) {
+
+            // Array-type parameter
+            List<String> paramValues = handleArrayTypeParamPhrase(parameter);
+
+            // Command-type parameter
+            if (paramValues == null) {
+                paramValues = handleCommandTypeParamPhrase(parameter, keep, currentParameterValuesMap, isRefreshGlobalParameters);
+            }
+
+            String selectedParamValue = null;
+            if (paramValues != null) {
+                selectedParamValue = displayParamValuesOptionsDialog(parameter, paramValues);
+            } else {
+                // free text parameter
+                log.debug("Parameter [{}] is of a free-text type", parameter);
+
+                selectedParamValue = JOptionPane.showInputDialog(
+                        Application.getContext().getGui().getContentPane(),
+                        String.format("Input a value for %s", parameter.getName()),
+                        "Set parameter value",
+                        JOptionPane.QUESTION_MESSAGE);
+                log.debug("Value of [{}] was set to free-text parameter [{}]", selectedParamValue, parameter);
+            }
+
+            if (StringUtils.isEmpty(selectedParamValue)) {
+                JOptionPane.showMessageDialog(
+                        Application.getContext().getGui(),
+                        String.format("Value for parameter \"%s\" is not set, cancelling processing the Keep",
+                                parameter.getName())
+                );
+                log.debug(
+                        "The user probably clicked on the cancel button on the dialog to set a free-text for "
+                                + "the parameter [{}]", parameter);
+                throw new KeepParameterExecutionException("User cancelled");
+            } else {
+                if (keep.getPhrase() != null && !StringUtils.isEmpty(selectedParamValue)) {
+                    addParamValueToCurrentValues(parameter, currentParameterValuesMap, selectedParamValue);
+                    addParamValueToGlobalValues(parameter, selectedParamValue);
+                }
+            }
+        }
+    }
+
+    private static void addParamValueToCurrentValues(
+            KeepParameter parameter,
+            Map<String, String> currentParameterValuesMap,
+            String selectedParamValue) {
+        log.debug("Adding value of [{} for parameter [{}] to the current parameters values map", selectedParamValue, parameter);
+        currentParameterValuesMap.put(parameter.getName(), selectedParamValue);
+    }
+
+    private static void addParamValueToGlobalValues(KeepParameter parameter, String selectedParamValue) {
+        if (parameter.isGlobal()) {
+            log.debug(
+                    "As it is set to be global, adding value of [{}] for parameter [{}] to the global "
+                            + "parameters values map", selectedParamValue, parameter);
+            GLOBAL_PARAMETER_VALUES_MAP.put(parameter.getName(), selectedParamValue);
+        }
+    }
+
+    private String displayParamValuesOptionsDialog(KeepParameter parameter, List<String> keepResult) {
+        String selectedParamValue;
+        log.debug("Showing the user a dialog to choose a value for tha parameter [{}]", parameter);
+        selectedParamValue = (String) JOptionPane.showInputDialog(
+                Application.getContext().getGui().getContentPane(),
+                String.format("Choose a value for %s", parameter.getName()),
+                "Set parameter value",
+                JOptionPane.QUESTION_MESSAGE,
+                null,
+                parseToLineByLine(keepResult),
+                null);
+        log.debug("User selected the value [{}] for parameter [{}]", selectedParamValue, parameter);
+        if (StringUtils.isEmpty(selectedParamValue)) {
+            JOptionPane.showMessageDialog(
+                    Application.getContext().getGui(),
+                    String.format(
+                            "Value for parameter \"%s\" is not set, cancelling processing the Keep",
+                            parameter.getName())
+            );
+            log.debug(
+                    "The user probably clicked on the cancel button on the dialog to choose a value "
+                            + "for the parameter [{}]", parameter);
+            throw new KeepParameterExecutionException("User cancelled");
+        }
+        return selectedParamValue;
+    }
+
+    private List<String> handleCommandTypeParamPhrase(
+            KeepParameter parameter, Keep keep, Map<String, String> currentParameterValuesMap, boolean isRefreshGlobalParameters) {
+        List<String> keepResult = null;
 
-                // Keep parameter
+        if (!isFreeTextTypeParam(parameter)) {
+            try {
                 String paramKeepString = parameter.getPhrase();
 
-                // filling existing parameters values if already chosen and used in the next parameter
-                for (Map.Entry<String, String> currParam : currentParameterValuesMap.entrySet()) {
-                    if (currentParameterValuesMap.containsKey(currParam.getKey())) {
-                        paramKeepString = paramKeepString.replace(String.format("<%s>", currParam.getKey()), currParam.getValue());
-                        log.debug("Parameter [{}] was taken from current run parameters, selected value=[{}]", parameter, currParam.getValue());
-                    }
-                }
-
-                if (parameter.getPhrase().startsWith("[")) {
-                    // predefined array of values
-                    keepResult = Arrays.stream(parameter.getPhrase().substring(1, parameter.getPhrase().length() - 1)
-                                    .split(",")).map(String::trim)
-                            .collect(Collectors.toList());
-                    log.debug("Parameter [{}] is of array type, values=[{}]", parameter, keepResult);
-                } else {
-                    if (!StringUtils.isEmpty(paramKeepString)) {
-                        try {
-                            log.debug("Parameter [{}] is of Command type, executing param command [{}]", parameter, paramKeepString);
+                log.debug("Parameter [{}] is of Command type, executing param command [{}]", parameter, paramKeepString);
+                paramKeepString = populateParamPhraseWithAlreadySetParams(parameter, currentParameterValuesMap, paramKeepString);
 
-                            // checking if the param Keep uses parameters as well, and if so, executing those first
-                            for (KeepParameter innerParameter : keep.getParameters()) {
-                                if (paramKeepString.contains(String.format("<%s>", innerParameter.getName()))) {
-                                    // this parameter uses another one, so executing it first
-                                    executeParameter(innerParameter, keep, refreshParameters, currentParameterValuesMap);
-                                    paramKeepString = paramKeepString.replace(
-                                            String.format("<%s>", innerParameter.getName()),
-                                            currentParameterValuesMap.get(innerParameter.getName()));
-                                }
-                            }
+                // checking if the param Keep uses parameters as well, and if so, executing those first
+                for (KeepParameter innerParameter : keep.getParameters()) {
+                    if (paramKeepString.contains(String.format("<%s>", innerParameter.getName()))) {
+                        // this parameter uses another one, so executing it first
+                        executeParameter(innerParameter, keep, isRefreshGlobalParameters, currentParameterValuesMap);
+                        paramKeepString = paramKeepString.replace(
+                                String.format("<%s>", innerParameter.getName()),
+                                currentParameterValuesMap.get(innerParameter.getName()));
+                    }
+                }
 
-                            keepResult = executeCommand(paramKeepString);
-                            log.debug("Parameter [{}], Keep result=[{}]", parameter, keepResult);
-                        } catch (InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                        } catch (Exception e) {
-                            JOptionPane.showMessageDialog(
-                                    Application.getContext().getGui().getContentPane(),
-                                    String.format(
-                                            "Failed to run Keep \"%s\" for parameter \"%s\". %s.",
-                                            parameter.getPhrase(), parameter.getName(), e.getMessage()),
-                                    "Error when running a Keep",
-                                    JOptionPane.ERROR_MESSAGE
-                            );
-                            throw e;
-                        }
-                    }
-                }
-                if (keepResult != null) {
-                    log.debug("Showing the user a dialog to choose a value for tha parameter [{}]", parameter);
-                    selectedParamValue = (String) JOptionPane.showInputDialog(
-                            Application.getContext().getGui().getContentPane(),
-                            String.format("Choose a value for %s", parameter.getName()),
-                            "Set parameter value",
-                            JOptionPane.QUESTION_MESSAGE,
-                            null,
-                            parseToLineByLine(keepResult),
-                            null);
-                    log.debug("User selected the value [{}] for parameter [{}]", selectedParamValue, parameter);
-                    if (StringUtils.isEmpty(selectedParamValue)) {
-                        JOptionPane.showMessageDialog(
-                                Application.getContext().getGui(),
-                                String.format(
-                                        "Value for parameter \"%s\" is not set, cancelling processing the Keep",
-                                        parameter.getName())
-                        );
-                        log.debug(
-                                "The user probably clicked on the cancel button on the dialog to choose a value "
-                                        + "for the parameter [{}]", parameter);
-                        throw new RuntimeException("User cancelled");
-                    }
-                }
-            } else {
-                log.debug("Parameter [{}] is of a free-text type", parameter);
-                // free text parameter
-                selectedParamValue = JOptionPane.showInputDialog(
-                        Application.getContext().getGui().getContentPane(),
-                        String.format("Input a value for %s", parameter.getName()),
-                        "Set parameter value",
-                        JOptionPane.QUESTION_MESSAGE);
-                log.debug("Value of [{}] was set to free-text parameter [{}]", selectedParamValue, parameter);
-            }
+                keepResult = executeCommand(paramKeepString);
+                log.debug("Parameter [{}], Keep result=[{}]", parameter, keepResult);
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            } catch (Exception e) {
+                JOptionPane.showMessageDialog(
+                        Application.getContext().getGui().getContentPane(),
+                        String.format(
+                                "Failed to run Keep \"%s\" for parameter \"%s\". %s.",
+                                parameter.getPhrase(), parameter.getName(), e.getMessage()),
+                        "Error when running a Keep",
+                        JOptionPane.ERROR_MESSAGE
+                );
+            }
+        }
+        return keepResult;
+    }
+
+
+    private static String populateParamPhraseWithAlreadySetParams(
+            KeepParameter parameter, Map<String, String> currentParameterValuesMap, String paramKeepString) {
+        // filling existing parameters values if already chosen and used in the next parameter
+        for (Map.Entry<String, String> currParam : currentParameterValuesMap.entrySet()) {
+            paramKeepString = paramKeepString.replace(String.format("<%s>", currParam.getKey()), currParam.getValue());
+            log.debug("Parameter [{}] was taken from current run parameters, selected value=[{}]", parameter, currParam.getValue());
+        }
+        return paramKeepString;
+    }
+
+    private static boolean isFreeTextTypeParam(KeepParameter parameter) {
+        return parameter.getPhrase() == null || parameter.getPhrase().isEmpty();
+    }
 
-            if (StringUtils.isEmpty(selectedParamValue)) {
-                JOptionPane.showMessageDialog(
-                        Application.getContext().getGui(),
-                        String.format("Value for parameter \"%s\" is not set, cancelling processing the Keep",
-                                parameter.getName())
-                );
-                log.debug(
-                        "The user probably clicked on the cancel button on the dialog to set a free-text for "
-                                + "the parameter [{}]", parameter);
-                throw new RuntimeException("User cancelled");
-            } else {
-                if (keep.getPhrase() != null && !StringUtils.isEmpty(selectedParamValue)) {
-                    log.debug("Adding value of [{} for parameter [{}] to the current parameters values map", selectedParamValue, parameter);
-                    currentParameterValuesMap.put(parameter.getName(), selectedParamValue);
-                    if (parameter.isGlobal()) {
-                        log.debug(
-                                "As it is set to be global, adding value of [{}] for parameter [{}] to the global "
-                                        + "parameters values map", selectedParamValue, parameter);
-                        globalParameterValuesMap.put(parameter.getName(), selectedParamValue);
-                    }
-                }
-            }
-        }
+    private static boolean ifParamValueSet(KeepParameter parameter, Map<String, String> currentParameterValuesMap) {
+        return currentParameterValuesMap.containsKey(parameter.getName());
+    }
+
+    private static void setParamValueFromGlobal(KeepParameter parameter, Map<String, String> currentParameterValuesMap) {
+        String selectedParamValue;
+        selectedParamValue = GLOBAL_PARAMETER_VALUES_MAP.get(parameter.getName());
+        currentParameterValuesMap.put(parameter.getName(), selectedParamValue);
+        log.debug("Parameter [{}] was taken from global parameters, selected value=[{}]", parameter, selectedParamValue);
+    }
+
+    private static boolean isParamGlobalValueSet(KeepParameter parameter, boolean refreshParameters) {
+        return !refreshParameters && parameter.isGlobal() && GLOBAL_PARAMETER_VALUES_MAP.containsKey(parameter.getName());
     }
 
 
@@ -416,11 +490,7 @@
 
                 try {
                     executeParameter(parameter, keep, refreshParameters, currentParameterValuesMap);
-                } catch (InterruptedException ex) {
-                    log.error(FAILED_TO_EXECUTE_KEEP, ex);
-                    Thread.currentThread().interrupt();
-                }
-                catch (Exception ex) {
+                } catch (KeepParameterExecutionException ex) {
                     log.error(FAILED_TO_EXECUTE_KEEP, ex);
                     return null; // cancelling
                 }
@@ -443,7 +513,8 @@
         }
 
         if (!stringToParse.isEmpty() && stringToParse.get(0).equals("[")) {
-            // in case of a json array, an option to return visible and actual values for the dropdown lists (name of ec2 instance to display, the id to use on the command)
+            // in case of a json array, an option to return visible and actual values for the dropdown lists (name of ec2
+            // instance to display, the id to use on the command)
             // parse from a json array
             stringToParse.remove(0); // the opening '['
             stringToParse.remove(stringToParse.size() - 1); // the closing ']'
@@ -454,4 +525,38 @@
 
         return stringToParse.toArray(new String[stringToParse.size()]);
     }
+
+    private void handleOnlyCopy() {
+        new Thread(() -> {
+            Application.getContext().getGui().labelTargetWindow.setText("Keep copied, ready to paste...");
+            try {
+                TimeUnit.SECONDS.sleep(2);
+            } catch (InterruptedException e) {
+                log.error("Sleep interrupted exception", e);
+                Thread.currentThread().interrupt();
+            }
+            Application.getContext().getGui().labelTargetWindow.setText(ONLY_COPY_MODE);
+        }).start();
+    }
+
+    private void validateValueSetForGlobalParam(KeepParameter parameter,
+                                                Map<String, String> currentParameterValuesMap,
+                                                boolean refreshParameters) {
+        // checking if we already have a value for this parameter on the global parameters (unless refresh parameters was chosen)
+        if (isParamGlobalValueSet(parameter, refreshParameters)) {
+            setParamValueFromGlobal(parameter, currentParameterValuesMap);
+        }
+    }
+
+    private List<String> handleArrayTypeParamPhrase(KeepParameter parameter) {
+        List<String> keepResult = null;
+        if (!isFreeTextTypeParam(parameter) && parameter.getPhrase().startsWith("[")) {
+            // predefined array of values
+            keepResult = Arrays.stream(parameter.getPhrase().substring(1, parameter.getPhrase().length() - 1)
+                            .split(",")).map(String::trim)
+                    .collect(Collectors.toList());
+            log.debug("Parameter [{}] is of array type, values=[{}]", parameter, keepResult);
+        }
+        return keepResult;
+    }
 }
Index: logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.managers.window;\r\n\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.managers.KeepsManager;\r\nimport com.keepaste.logic.models.WindowInformation;\r\nimport com.keepaste.logic.utils.FileSystemUtils;\r\nimport com.keepaste.logic.utils.KeyboardUtils;\r\nimport lombok.NonNull;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport java.io.File;\r\nimport java.io.FileWriter;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * This class is Mac's {@link WindowManager}, it holds relevant methods related to windows management in Mac's OS's.\r\n */\r\n@Log4j2\r\npublic final class MacWindowsManager extends BaseWindowManager implements WindowManager {\r\n    public static final String GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME = \"GetTopMostWindow.applescript\";\r\n    private String lastTopMostWindowResult;\r\n\r\n    public MacWindowsManager() {\r\n        delAppleScriptFilesForRefresh();\r\n    }\r\n\r\n    @Override\r\n    public WindowInformation getActiveWindow() {\r\n        String topMostWindowResult = null;\r\n        try {\r\n            int tries = 3;\r\n            do {\r\n                topMostWindowResult = runAppleScriptFile(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME);\r\n\r\n                if (topMostWindowResult != null && !topMostWindowResult.equals(lastTopMostWindowResult)) {\r\n                    if (!topMostWindowResult.startsWith(\"success\")) {\r\n                        log.error(topMostWindowResult);\r\n                    } else {\r\n                        log.debug(\"top most window = [{}]\", topMostWindowResult);\r\n                        lastTopMostWindowResult = topMostWindowResult;\r\n                        topMostWindowResult = topMostWindowResult.replace(\"}\", \"\");\r\n                        topMostWindowResult = topMostWindowResult.replace(\"{\", \"\");\r\n                        topMostWindowResult = topMostWindowResult.replace(\" \", \"\");\r\n                        String[] activeWindowSegments = topMostWindowResult.split(\",\");\r\n                        String text = activeWindowSegments[2];\r\n                        String app = activeWindowSegments[1];\r\n                        return WindowInformation.builder()\r\n                                .text(text)\r\n                                .app(app)\r\n                                .top(0)\r\n                                .bottom(0)\r\n                                .left(0)\r\n                                .right(0)\r\n                                .processId(Integer.parseInt(activeWindowSegments[3]))\r\n                                .build();\r\n\r\n                    }\r\n                    lastTopMostWindowResult = topMostWindowResult;\r\n                }\r\n                Thread.sleep(150);\r\n                tries--;\r\n            } while (tries > 0);\r\n        } catch (InterruptedException ex) {\r\n            // Restore interrupted state...\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception ex) {\r\n            log.debug(String.format(\"Failed to get active window, top most window=[%s]\", topMostWindowResult == null ? \"null\" : topMostWindowResult), ex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void paste() {\r\n        log.debug(\"Pasting using osascript for CMD+V (Apple)\");\r\n        try {\r\n            // this is commented out as it doesn't work well when the command is on one language (English) and the operating system input is set to be in another language (such as Hebrew)\r\n            // so shifted to use cmd+V\r\n            //            Application.getContext().getKeepExecutionManager().executeCommand(\"osascript -e 'tell application \\\"System Events\\\" to keystroke \\\"v\\\" using command down'\");\r\n            cmdV();\r\n            TimeUnit.MILLISECONDS.sleep(50);\r\n//        } catch (IOException e) {\r\n//            log.error(\"Failed to paste for mac\", e);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to paste on Mac\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean focusOnActiveWindow(@NonNull final WindowInformation windowContext) {\r\n        try {\r\n            log.debug(\"Switching to next window\");\r\n            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(\"osascript -e 'tell application \\\"System Events\\\" to key code 118 using control down'\");\r\n            // validating that the window is the desired one\r\n            return Application.getContext().getModelActiveWindow().getActiveWindow().equals(windowContext);\r\n        } catch (InterruptedException e) {\r\n            log.error(String.format(\"Failed to focus on window [%s]\", windowContext), e);\r\n            Thread.currentThread().interrupt();\r\n            return false;\r\n        } catch (Exception e) {\r\n            log.error(String.format(\"Failed to focus on window [%s]\", windowContext), e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Runs applescript files.\r\n     *\r\n     * @param filename      the filename of the applescript file\r\n     * @param params       relevant command parameters\r\n     * @return             the output as a String\r\n     */\r\n    public String runAppleScriptFile(String filename, String... params) {\r\n        try {\r\n            String filePath = FileSystemUtils.getKeepasteDirectory().concat(\"/\").concat(filename);\r\n            File scriptFile = new File(filePath);\r\n            if (!scriptFile.exists()) {\r\n                try (InputStream inputStream = KeepsManager.class.getResourceAsStream(\"/scripts/mac/\".concat(filename))) {\r\n                    if (inputStream != null) {\r\n                        String fileContents = new String(inputStream.readAllBytes());\r\n                        try (FileWriter writer = new FileWriter(filePath)) {\r\n                            log.info(\"Saved \".concat(filePath));\r\n                            writer.write(fileContents);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            String command = \"osascript \".concat(scriptFile.getAbsolutePath());\r\n\r\n            for (String param : params) {\r\n                command = command.concat(\" \\\"\").concat(param).concat(\"\\\"\");\r\n            }\r\n\r\n            List<String> output = Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(command);\r\n            if (!output.isEmpty()) {\r\n                return output.get(0);\r\n            }\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception e) {\r\n            log.error(String.format(\"Failed to run apple script file [%s]\", filename), e);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will delete the used applescript files from the .keepaste folder in order to keep those refreshed, if any changes were done to them between versions.\r\n     */\r\n    private void delAppleScriptFilesForRefresh() {\r\n        FileSystemUtils.deleteFile(FileSystemUtils.getKeepasteDirectory().concat(\"/\").concat(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME));\r\n    }\r\n\r\n    /**\r\n     * imitating a cmd+v press for pasting on Mac.\r\n     */\r\n    private void cmdV() {\r\n        log.debug(\"Robot pressing CMD+V (pasting on mac)\");\r\n        KeyboardUtils.cmdV();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java b/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java
--- a/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java	(revision 6b388e737d259f725c36eacdeab1821d3f311995)
+++ b/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java	(date 1698616397923)
@@ -35,10 +35,16 @@
  * This class is Mac's {@link WindowManager}, it holds relevant methods related to windows management in Mac's OS's.
  */
 @Log4j2
-public final class MacWindowsManager extends BaseWindowManager implements WindowManager {
+public final class MacWindowsManager implements WindowManager {
     public static final String GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME = "GetTopMostWindow.applescript";
+    public static final int GET_ACTIVE_WINDOW_NUM_TRIES = 3;
+    public static final int SLEEP_INTERVAL_BETWEEN_RETRIES = 150;
+    public static final int SLEEP_AFTER_PASTE_IN_MS = 50;
     private String lastTopMostWindowResult;
 
+    /**
+     * Constructor.
+     */
     public MacWindowsManager() {
         delAppleScriptFilesForRefresh();
     }
@@ -47,7 +53,7 @@
     public WindowInformation getActiveWindow() {
         String topMostWindowResult = null;
         try {
-            int tries = 3;
+            int tries = GET_ACTIVE_WINDOW_NUM_TRIES;
             do {
                 topMostWindowResult = runAppleScriptFile(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME);
 
@@ -70,20 +76,21 @@
                                 .bottom(0)
                                 .left(0)
                                 .right(0)
-                                .processId(Integer.parseInt(activeWindowSegments[3]))
+                                .processId(Integer.parseInt(activeWindowSegments[GET_ACTIVE_WINDOW_NUM_TRIES]))
                                 .build();
 
                     }
                     lastTopMostWindowResult = topMostWindowResult;
                 }
-                Thread.sleep(150);
+                TimeUnit.MILLISECONDS.sleep(SLEEP_INTERVAL_BETWEEN_RETRIES);
                 tries--;
             } while (tries > 0);
         } catch (InterruptedException ex) {
             // Restore interrupted state...
             Thread.currentThread().interrupt();
         } catch (Exception ex) {
-            log.debug(String.format("Failed to get active window, top most window=[%s]", topMostWindowResult == null ? "null" : topMostWindowResult), ex);
+            log.debug(String.format("Failed to get active window, top most window=[%s]",
+                    topMostWindowResult == null ? "null" : topMostWindowResult), ex);
         }
         return null;
     }
@@ -92,13 +99,9 @@
     public void paste() {
         log.debug("Pasting using osascript for CMD+V (Apple)");
         try {
-            // this is commented out as it doesn't work well when the command is on one language (English) and the operating system input is set to be in another language (such as Hebrew)
-            // so shifted to use cmd+V
-            //            Application.getContext().getKeepExecutionManager().executeCommand("osascript -e 'tell application \"System Events\" to keystroke \"v\" using command down'");
-            cmdV();
-            TimeUnit.MILLISECONDS.sleep(50);
-//        } catch (IOException e) {
-//            log.error("Failed to paste for mac", e);
+            Application.getContext().getKeepExecutionManager().executeCommand(
+                    "osascript -e 'tell application \"System Events\" to key code {9} using command down'");
+            TimeUnit.MILLISECONDS.sleep(SLEEP_AFTER_PASTE_IN_MS);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
         } catch (Exception e) {
@@ -110,7 +113,8 @@
     public boolean focusOnActiveWindow(@NonNull final WindowInformation windowContext) {
         try {
             log.debug("Switching to next window");
-            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath("osascript -e 'tell application \"System Events\" to key code 118 using control down'");
+            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(
+                    "osascript -e 'tell application \"System Events\" to key code 118 using control down'");
             // validating that the window is the desired one
             return Application.getContext().getModelActiveWindow().getActiveWindow().equals(windowContext);
         } catch (InterruptedException e) {
@@ -166,17 +170,11 @@
     }
 
     /**
-     * Will delete the used applescript files from the .keepaste folder in order to keep those refreshed, if any changes were done to them between versions.
+     * Will delete the used applescript files from the .keepaste folder in order to keep those refreshed, if any changes
+     * were done to them between versions.
      */
     private void delAppleScriptFilesForRefresh() {
         FileSystemUtils.deleteFile(FileSystemUtils.getKeepasteDirectory().concat("/").concat(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME));
     }
 
-    /**
-     * imitating a cmd+v press for pasting on Mac.
-     */
-    private void cmdV() {
-        log.debug("Robot pressing CMD+V (pasting on mac)");
-        KeyboardUtils.cmdV();
-    }
 }
Index: logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.views;\r\n\r\nimport com.keepaste.gui.DialogKeep;\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.AddParamActionListener;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.ExistingParamActionListener;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.RemoveParamActionListener;\r\nimport com.keepaste.logic.models.Keep;\r\nimport com.keepaste.logic.models.KeepsGroup;\r\nimport com.keepaste.logic.models.KeepParameter;\r\nimport com.keepaste.logic.utils.GuiUtils;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport javax.swing.*;\r\nimport javax.swing.table.TableCellEditor;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * This View class manages the {@link DialogKeep}.\r\n */\r\npublic class ViewDialogKeep {\r\n    final DialogKeep dialogKeep = new DialogKeep(Application.getContext().getGui(), true);\r\n    private final List<KeepParameter> editedParameters;\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param keep      the {@link Keep} in context\r\n     */\r\n    public ViewDialogKeep(final Keep keep) {\r\n        dialogKeep.setAlwaysOnTop(true);\r\n        dialogKeep.setModal(true);\r\n\r\n        dialogKeep.setLocationRelativeTo(Application.getContext().getGui());\r\n\r\n        dialogKeep.textName.setText(keep.getTitle());\r\n        dialogKeep.textKeep.setText(keep.getPhrase());\r\n        dialogKeep.textDescription.setText(keep.getDescription());\r\n\r\n        // parameters\r\n        this.editedParameters = keep.getParameters() == null ? new ArrayList<>() : new ArrayList<>(keep.getParameters());\r\n        dialogKeep.tableParams.setModel(getTableModel());\r\n\r\n        dialogKeep.buttonAddParam.addActionListener(new AddParamActionListener(dialogKeep.tableParams));\r\n        dialogKeep.buttonRemoveParam.addActionListener(new RemoveParamActionListener(dialogKeep.tableParams));\r\n        dialogKeep.buttonExistingParam.addActionListener(new ExistingParamActionListener(dialogKeep));\r\n\r\n        dialogKeep.buttonCancel.addActionListener(e -> dialogKeep.setVisible(false));\r\n\r\n        dialogKeep.buttonOK.addActionListener(e -> {\r\n            if (dialogKeep.tableParams.isEditing()) {\r\n                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());\r\n                if (cellEditor != null) {\r\n                    cellEditor.stopCellEditing();\r\n                }\r\n            }\r\n            if (StringUtils.isEmpty(dialogKeep.textKeep.getText()) || StringUtils.isEmpty(dialogKeep.textName.getText())) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"Both Name and Keep fields are mandatory\", \"Not enough...\", JOptionPane.ERROR_MESSAGE);\r\n                return;\r\n            }\r\n            // validating that there are no duplications in parameter names\r\n            if (editedParameters.stream().map(KeepParameter::getName).distinct().count() < editedParameters.size()) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"There are duplications in parameters names, please review\");\r\n                return;\r\n            }\r\n\r\n            // validating that all command parameters are met\r\n            String commandStr = dialogKeep.textKeep.getText();\r\n            for (KeepParameter parameter : editedParameters) {\r\n                commandStr = commandStr.replace(String.format(\"<%s>\", parameter.getName()), \"\");\r\n            }\r\n            if (commandStr.contains(\"<\") && commandStr.contains(\">\")) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"Given parameters does not cover all keep parameters, please add missing ones\");\r\n                return;\r\n            }\r\n\r\n            // also for parameters\r\n            for (KeepParameter parameter : editedParameters) {\r\n                String parameterPhrase = parameter.getPhrase();\r\n                for (KeepParameter otherParameters : editedParameters) {\r\n                    if (otherParameters == parameter) {\r\n                        // validating that a keep parameter doesn't reference itself\r\n                        if (parameterPhrase.contains(String.format(\"<%s>\", parameter.getName()))) {\r\n                            JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format(\"The parameter %s cannot use its own name as a command parameter.\", parameter.getName()));\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        parameterPhrase = parameterPhrase.replace(String.format(\"<%s>\", otherParameters.getName()), \"\");\r\n                    }\r\n                }\r\n                int startIndex = parameterPhrase.indexOf(\"<\");\r\n                int endIndex = parameterPhrase.indexOf(\">\", startIndex);\r\n                if (startIndex > 0 && endIndex > 0) {\r\n                    String missingParamName = parameterPhrase.substring(startIndex + 1, endIndex);\r\n                    JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format(\"Given parameters does not cover all used parameters (on keep or its parameters), please add the following missing parameter - %s\", missingParamName));\r\n                    return;\r\n                }\r\n            }\r\n\r\n            keep.setTitle(dialogKeep.textName.getText().trim());\r\n            keep.setPhrase(dialogKeep.textKeep.getText().trim());\r\n            keep.setDescription(dialogKeep.textDescription.getText().trim());\r\n            keep.setNeverPressEnter(dialogKeep.checkNeverPressEnter.isSelected());\r\n            // getting parameters\r\n            keep.setParameters(editedParameters);\r\n            KeepsGroup rootNode = Application.getContext().getKeepsManager().getRootNode();\r\n            Application.getContext().getKeepsManager().saveKeeps(rootNode);\r\n            dialogKeep.setVisible(false);\r\n        });\r\n        GuiUtils.showDialogOnCenterScreen(dialogKeep);\r\n    }\r\n\r\n    private KeepParametersTableModel getTableModel() {\r\n        return new KeepParametersTableModel(editedParameters);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java b/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java
--- a/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java	(revision 6b388e737d259f725c36eacdeab1821d3f311995)
+++ b/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java	(date 1698616397953)
@@ -54,6 +54,7 @@
         dialogKeep.textName.setText(keep.getTitle());
         dialogKeep.textKeep.setText(keep.getPhrase());
         dialogKeep.textDescription.setText(keep.getDescription());
+        dialogKeep.checkNeverPressEnter.setSelected(keep.isNeverPressEnter());
 
         // parameters
         this.editedParameters = keep.getParameters() == null ? new ArrayList<>() : new ArrayList<>(keep.getParameters());
@@ -67,18 +68,21 @@
 
         dialogKeep.buttonOK.addActionListener(e -> {
             if (dialogKeep.tableParams.isEditing()) {
-                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());
+                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(
+                        dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());
                 if (cellEditor != null) {
                     cellEditor.stopCellEditing();
                 }
             }
             if (StringUtils.isEmpty(dialogKeep.textKeep.getText()) || StringUtils.isEmpty(dialogKeep.textName.getText())) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "Both Name and Keep fields are mandatory", "Not enough...", JOptionPane.ERROR_MESSAGE);
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "Both Name and Keep fields are mandatory", "Not enough...", JOptionPane.ERROR_MESSAGE);
                 return;
             }
             // validating that there are no duplications in parameter names
             if (editedParameters.stream().map(KeepParameter::getName).distinct().count() < editedParameters.size()) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "There are duplications in parameters names, please review");
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "There are duplications in parameters names, please review");
                 return;
             }
 
@@ -88,7 +92,8 @@
                 commandStr = commandStr.replace(String.format("<%s>", parameter.getName()), "");
             }
             if (commandStr.contains("<") && commandStr.contains(">")) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "Given parameters does not cover all keep parameters, please add missing ones");
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "Given parameters does not cover all keep parameters, please add missing ones");
                 return;
             }
 
@@ -99,7 +104,8 @@
                     if (otherParameters == parameter) {
                         // validating that a keep parameter doesn't reference itself
                         if (parameterPhrase.contains(String.format("<%s>", parameter.getName()))) {
-                            JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format("The parameter %s cannot use its own name as a command parameter.", parameter.getName()));
+                            JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                                    String.format("The parameter %s cannot use its own name as a command parameter.", parameter.getName()));
                             return;
                         }
                     } else {
@@ -110,7 +116,9 @@
                 int endIndex = parameterPhrase.indexOf(">", startIndex);
                 if (startIndex > 0 && endIndex > 0) {
                     String missingParamName = parameterPhrase.substring(startIndex + 1, endIndex);
-                    JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format("Given parameters does not cover all used parameters (on keep or its parameters), please add the following missing parameter - %s", missingParamName));
+                    JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                            String.format("Given parameters does not cover all used parameters (on keep or its parameters),"
+                                    + " please add the following missing parameter - %s", missingParamName));
                     return;
                 }
             }
