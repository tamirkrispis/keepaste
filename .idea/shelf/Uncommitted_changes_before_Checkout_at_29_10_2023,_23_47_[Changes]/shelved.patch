Index: logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.utils;\r\n\r\nimport com.keepaste.logic.exceptions.KeepasteGenericException;\r\nimport lombok.Setter;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport java.awt.*;\r\nimport java.awt.event.KeyEvent;\r\n\r\n/**\r\n * This class is a utility class for anything related to simulating keyboard clicks.\r\n */\r\n@Log4j2\r\npublic final class KeyboardUtils {\r\n    private static final Robot ROBOT;\r\n    public static final int ROBOT_DELAY_IN_MS = 50;\r\n\r\n    private KeyboardUtils() {\r\n        // private constructor for utils class\r\n    }\r\n\r\n    static {\r\n        try {\r\n            ROBOT = new Robot();\r\n            ROBOT.setAutoWaitForIdle(true);\r\n        } catch (AWTException e) {\r\n            throw new KeepasteGenericException(\"Failed to initialize Robot class\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Imitate pressing the 'Enter' key.\r\n     */\r\n    public static void enter() {\r\n        log.debug(\"Robot pressing ENTER\");\r\n        ROBOT.keyPress(KeyEvent.VK_ENTER);\r\n        ROBOT.keyRelease(KeyEvent.VK_ENTER);\r\n    }\r\n\r\n    /**\r\n     * Imitate pressing a keyboard key.\r\n     *\r\n     * @param keyEventCode the key code of the keyboard button\r\n     */\r\n    public static void keyPress(final int keyEventCode) {\r\n        ROBOT.keyPress(keyEventCode);\r\n    }\r\n\r\n    /**\r\n     * Imitate releasing a keyboard key.\r\n     *\r\n     * @param keyEventCode the key code of the keyboard button\r\n     */\r\n    public static void keyRelease(final int keyEventCode) {\r\n        ROBOT.keyRelease(keyEventCode);\r\n    }\r\n\r\n    /**\r\n     * Perform a delay between key strokes.\r\n     *\r\n     * @param ms the time interval in ms to delay.\r\n     */\r\n    public static void delay(final int ms) {\r\n        ROBOT.delay(ms);\r\n    }\r\n\r\n    /**\r\n     * Will initiate cmd+v keypress sequence.\r\n     */\r\n    public static void cmdV() {\r\n        ROBOT.keyPress(KeyEvent.VK_SHIFT);\r\n        ROBOT.keyRelease(KeyEvent.VK_SHIFT);\r\n        // VK_META is problematic on Mac, so this is a hack for pressing it for several times, then releasing it, so at least one will be simulated\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.keyPress(KeyEvent.VK_META);\r\n        ROBOT.delay(ROBOT_DELAY_IN_MS);\r\n        ROBOT.keyPress(KeyEvent.VK_V);\r\n        ROBOT.delay(ROBOT_DELAY_IN_MS);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_META);\r\n        ROBOT.keyRelease(KeyEvent.VK_V);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java b/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java
--- a/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java	(revision 2f3a4c4b47e0711d04fd9b73994bd1daab9f3eee)
+++ b/logic/src/main/java/com/keepaste/logic/utils/KeyboardUtils.java	(date 1698615901657)
@@ -19,7 +19,6 @@
 package com.keepaste.logic.utils;
 
 import com.keepaste.logic.exceptions.KeepasteGenericException;
-import lombok.Setter;
 import lombok.extern.log4j.Log4j2;
 import java.awt.*;
 import java.awt.event.KeyEvent;
@@ -81,26 +80,4 @@
         ROBOT.delay(ms);
     }
 
-    /**
-     * Will initiate cmd+v keypress sequence.
-     */
-    public static void cmdV() {
-        ROBOT.keyPress(KeyEvent.VK_SHIFT);
-        ROBOT.keyRelease(KeyEvent.VK_SHIFT);
-        // VK_META is problematic on Mac, so this is a hack for pressing it for several times, then releasing it, so at least one will be simulated
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.keyPress(KeyEvent.VK_META);
-        ROBOT.delay(ROBOT_DELAY_IN_MS);
-        ROBOT.keyPress(KeyEvent.VK_V);
-        ROBOT.delay(ROBOT_DELAY_IN_MS);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_META);
-        ROBOT.keyRelease(KeyEvent.VK_V);
-    }
 }
Index: logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.keepaste.logic.managers;\r\n\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.exceptions.KeepExecutionException;\r\nimport com.keepaste.logic.exceptions.KeepParameterExecutionException;\r\nimport com.keepaste.logic.models.Keep;\r\nimport com.keepaste.logic.models.KeepParameter;\r\nimport com.keepaste.logic.models.WindowInformation;\r\nimport com.keepaste.logic.utils.ClipboardUtils;\r\nimport com.keepaste.logic.utils.FileSystemUtils;\r\nimport com.keepaste.logic.utils.KeyboardUtils;\r\nimport com.keepaste.logic.utils.OperatingSystemUtils;\r\nimport lombok.Getter;\r\nimport lombok.NonNull;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport javax.swing.*;\r\nimport java.awt.event.KeyListener;\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.stream.Collectors;\r\nimport static com.keepaste.logic.common.Constants.ONLY_COPY_MODE;\r\n\r\n/**\r\n * This class hods methods related to Keep execution.\r\n */\r\n@Log4j2\r\npublic final class KeepExecutionManager {\r\n    public static final String FAILED_TO_EXECUTE_KEEP = \"Failed to execute keep\";\r\n    @Getter\r\n    private static final Map<String, String> GLOBAL_PARAMETER_VALUES_MAP = new HashMap<>();\r\n    public static final int COMMAND_EXEC_TIMEOUT = 15;\r\n\r\n    private String shell = \"/bin/bash\";\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @throws IOException          on error\r\n     * @throws InterruptedException on error\r\n     */\r\n    public KeepExecutionManager() {\r\n        if (OperatingSystemUtils.getOperatingSystemType() != OperatingSystemUtils.OperatingSystemType.WINDOWS) {\r\n            try {\r\n                List<String> shellValue = executeCommandWithDefaultPath(\"echo $SHELL\");\r\n                if (!shellValue.isEmpty()) {\r\n                    shell = shellValue.get(0);\r\n                    log.debug(\"Shell set to [{}]\", shell);\r\n                }\r\n            } catch (Exception ex) {\r\n                log.error(String.format(\"Failed to get shell, using default shell of [%s]\", shell), ex);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Executed a selected {@link Keep} on the currently active window.\r\n     *\r\n     * @param keep the {@link Keep} to execute\r\n     */\r\n    public void executeKeepOnWindow(Keep keep) {\r\n        executeKeepOnWindow(keep, false);\r\n    }\r\n\r\n    /**\r\n     * Executed a selected {@link Keep} on the currently active window.\r\n     *\r\n     * @param keep the {@link Keep} to execute\r\n     * @param refreshParameters true if we wish to clear the existing global parameters and have a fresh start\r\n     */\r\n    public void executeKeepOnWindow(Keep keep, boolean refreshParameters) {\r\n        log.info(\r\n                \"Executing Keep [{}] on window [{}] with refresh parameters [{}]\",\r\n                keep.toStringAll(), Application.getContext().getModelActiveWindow(), refreshParameters);\r\n\r\n        // clearing selection from tree not to accidentally executing the selected node when the user presses the 'enter'\r\n        // key (like on dialogs)\r\n        var currentSelectionPath = Application.getContext().getGui().tree.getSelectionPath();\r\n        Application.getContext().getGui().tree.clearSelection();\r\n\r\n        // stopping window interception while running the Keep to prevent pasting on wrong window\r\n        Application.getContext().stopWindowInterceptorRunner();\r\n\r\n        // keeping the active window that the user meant to paste on\r\n        WindowInformation currentlyActiveWindow = Application.getContext().getModelActiveWindow().getActiveWindow();\r\n\r\n        // validating that only one keep is running at a time\r\n        if (Application.getContext().isKeepCurrentlyRunning()) {\r\n            JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                    \"Can only run one Keep at a time, please wait for the other Keep to finish or abort it\",\r\n                    \"One Keep at a time please\", JOptionPane.WARNING_MESSAGE);\r\n            return;\r\n        }\r\n\r\n        Application.getContext().setKeepCurrentlyRunning(true);\r\n\r\n        // preventing from enter being pressed on dialogs shown while manipulating parameters from triggering the tree's\r\n        // key listener (prevents from running another keep by mistake when pressing ENTER)\r\n        Optional<KeyListener> viewTreeKeyListener =\r\n                Arrays.stream(Application.getContext().getGui().tree.getKeyListeners())\r\n                        .filter(keyListener -> keyListener.getClass().getName().contains(\"ViewTree\"))\r\n                        .findFirst();\r\n        viewTreeKeyListener.ifPresent(keyListener -> Application.getContext().getGui().tree.removeKeyListener(keyListener));\r\n\r\n        Application.getContext().getGui().labelBackground.setText(\"Executing keep...\");\r\n        Application.getContext().getGui().labelBackground.setVisible(true);\r\n        SwingWorker<Void, String> worker = new SwingWorker<>() {\r\n            @Override\r\n            protected Void doInBackground() {\r\n//                try {\r\n                    String keepToExecute = manipulateParameters(keep, refreshParameters);\r\n                    log.info(\"Final Keep to execute [{}]\", keepToExecute);\r\n                    if (!StringUtils.isEmpty(keepToExecute)) {\r\n\r\n                        copyToClipboard(keepToExecute);\r\n\r\n                        if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {\r\n                            handleOnlyCopy();\r\n                        } else {\r\n                            if (isFocusOnActiveWindow(currentlyActiveWindow)) {\r\n                                pasteKeep();\r\n                                pressEnter(keep);\r\n                            } else {\r\n                                handleWrongTargetWindow();\r\n                            }\r\n                        }\r\n                    }\r\n//                }\r\n\r\n//                catch (Exception e) {\r\n//                    JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n//                            FAILED_TO_EXECUTE_KEEP,\r\n//                            \"Bummer...\",\r\n//                            JOptionPane.ERROR_MESSAGE);\r\n//                    log.error(FAILED_TO_EXECUTE_KEEP, e);\r\n//                    throw e;\r\n//                }\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n            protected void done() {\r\n                Application.getContext().getGui().labelBackground.setVisible(false);\r\n                Application.getContext().setKeepCurrentlyRunning(false);\r\n\r\n                viewTreeKeyListener.ifPresent(keyListener -> Application.getContext().getGui().tree.addKeyListener(keyListener));\r\n\r\n                Application.getContext().setKeepCurrentlyRunning(false);\r\n                Application.getContext().startWindowInterceptorRunner();\r\n\r\n                Application.getContext().getGui().tree.setSelectionPath(currentSelectionPath);\r\n\r\n                log.debug(\"Keep execution finished\");\r\n            }\r\n        };\r\n        worker.execute();\r\n    }\r\n\r\n    private static void copyToClipboard(String keepToExecute) {\r\n        // setting final keep command to the clipboard\r\n        log.debug(\"Setting [{}] to clipboard\", keepToExecute);\r\n        ClipboardUtils.setValue(keepToExecute);\r\n    }\r\n\r\n    private static void handleWrongTargetWindow() {\r\n        JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                \"Seems like keepaste is not focused on the desired window, please try again...\",\r\n                \"Warning\",\r\n                JOptionPane.WARNING_MESSAGE);\r\n        log.debug(\"Not focused on correct window so not pasting and pressing ENTER\");\r\n    }\r\n\r\n    private static void pressEnter(Keep keep) {\r\n        if (Application.getContext().getModelSettings().isPressEnterAfterPaste()) {\r\n            if (keep.isNeverPressEnter()) {\r\n                log.debug(\"keep is set to never press 'enter' so it didn't\");\r\n            } else {\r\n                log.debug(\"Imitating \\\"ENTER\\\" key\");\r\n                KeyboardUtils.enter();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void pasteKeep() {\r\n        if (Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {\r\n            log.debug(\"pasting \".concat(ClipboardUtils.getValue().toString()));\r\n            Application.getContext().getWindowManager().paste();\r\n        }\r\n    }\r\n\r\n    private static boolean isFocusOnActiveWindow(WindowInformation currentlyActiveWindow) {\r\n        if (currentlyActiveWindow == null) {\r\n            JOptionPane.showMessageDialog(Application.getContext().getGui(),\r\n                    \"Please select a window by clicking on it in order to run Keeps\",\r\n                    \"No active window\", JOptionPane.WARNING_MESSAGE);\r\n            throw new KeepExecutionException(\"No active window is set\");\r\n        } else {\r\n            return Application.getContext().getWindowManager().focusOnActiveWindow(currentlyActiveWindow);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param command the command to execute\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommandWithDefaultPath(String command) throws KeepExecutionException, IOException, InterruptedException {\r\n        return executeCommand(List.of(command), true);\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param command the command to execute\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommand(String command) throws KeepExecutionException, IOException, InterruptedException {\r\n        return executeCommand(List.of(command), false);\r\n    }\r\n\r\n    /**\r\n     * Will execute a command in shell and return its output as a list of Strings.\r\n     *\r\n     * @param commandLines  the command lines to execute\r\n     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal commands (like intercepting the currently active window)\r\n     * @return  the execution output\r\n     * @throws IOException in case of execution failure\r\n     * @throws InterruptedException in case of execution failure\r\n     */\r\n    public List<String> executeCommand(List<String> commandLines, boolean defaultPath) throws KeepExecutionException, IOException, InterruptedException {\r\n        ProcessBuilder processBuilder = new ProcessBuilder();\r\n        // Set the working directory for the process\r\n        processBuilder.directory(new File(FileSystemUtils.getUserHomeDirectory()));\r\n\r\n        List<String> newKeep = new ArrayList<>();\r\n\r\n        OperatingSystemUtils.OperatingSystemType os = OperatingSystemUtils.getOperatingSystemType();\r\n        switch (os.name()) {\r\n            case OperatingSystemUtils.WINDOWS:\r\n                newKeep.add(\"powershell.exe\");\r\n                newKeep.add(\"-Command\");\r\n                newKeep.addAll(commandLines);\r\n                processBuilder.command(newKeep);\r\n                break;\r\n            case OperatingSystemUtils.MAC:\r\n            case OperatingSystemUtils.LINUX:\r\n            case OperatingSystemUtils.OTHER:\r\n            default:\r\n                if (!defaultPath) {\r\n                    // Get the environment variables\r\n                    Map<String, String> environment = processBuilder.environment();\r\n                    environment.put(\"PATH\", Application.getContext().getModelSettings().getPath());\r\n                }\r\n\r\n                newKeep.add(shell);\r\n                newKeep.add(\"-c\");\r\n                newKeep.addAll(commandLines);\r\n                processBuilder.command(newKeep);\r\n                break;\r\n        }\r\n        processBuilder.redirectErrorStream(true);\r\n        Process process = processBuilder.start();\r\n\r\n        InputStream inputStream = process.getInputStream();\r\n\r\n        BufferedReader reader =\r\n                new BufferedReader(new InputStreamReader(inputStream));\r\n\r\n        int timeout = COMMAND_EXEC_TIMEOUT;\r\n        do {\r\n            timeout--;\r\n            process.waitFor(1, TimeUnit.SECONDS);\r\n        } while (process.isAlive() && timeout > 0);\r\n\r\n        if (timeout <= 0) {\r\n            throw new KeepExecutionException(\"Command timeout exceeded (10 sec.)\");\r\n        }\r\n\r\n        String line;\r\n        List<String> outputLines = new ArrayList<>();\r\n        if (inputStream.available() > 0) {\r\n            while ((line = reader.readLine()) != null) {\r\n                outputLines.add(line);\r\n            }\r\n        }\r\n        inputStream.close();\r\n        return outputLines;\r\n    }\r\n\r\n    /**\r\n     * Will manage a Keep parameter.\r\n     *\r\n     * @param parameter                 the {@link KeepParameter} to handle\r\n     * @param keep                      the {@link Keep} in context\r\n     * @param isRefreshGlobalParameters         if to refresh the global parameters\r\n     * @param currentParameterValuesMap the current global parameters cache\r\n     * @throws Exception in case of any error\r\n     */\r\n    private void executeParameter(\r\n            @NonNull final KeepParameter parameter,\r\n            @NonNull final Keep keep,\r\n            final boolean isRefreshGlobalParameters,\r\n            @NonNull final Map<String, String> currentParameterValuesMap) {\r\n\r\n        // in case of this is a global parameter, checking if the value already exist for it\r\n        validateValueSetForGlobalParam(parameter, currentParameterValuesMap, isRefreshGlobalParameters);\r\n\r\n        // in case the value doesn't exist yet\r\n        if (!ifParamValueSet(parameter, currentParameterValuesMap)) {\r\n\r\n            // Array-type parameter\r\n            List<String> paramValues = handleArrayTypeParamPhrase(parameter);\r\n\r\n            // Command-type parameter\r\n            if (paramValues == null) {\r\n                paramValues = handleCommandTypeParamPhrase(parameter, keep, currentParameterValuesMap, isRefreshGlobalParameters);\r\n            }\r\n\r\n            String selectedParamValue = null;\r\n            if (paramValues != null) {\r\n                selectedParamValue = displayParamValuesOptionsDialog(parameter, paramValues);\r\n            } else {\r\n                // free text parameter\r\n                log.debug(\"Parameter [{}] is of a free-text type\", parameter);\r\n\r\n                selectedParamValue = JOptionPane.showInputDialog(\r\n                        Application.getContext().getGui().getContentPane(),\r\n                        String.format(\"Input a value for %s\", parameter.getName()),\r\n                        \"Set parameter value\",\r\n                        JOptionPane.QUESTION_MESSAGE);\r\n                log.debug(\"Value of [{}] was set to free-text parameter [{}]\", selectedParamValue, parameter);\r\n            }\r\n\r\n            if (StringUtils.isEmpty(selectedParamValue)) {\r\n                JOptionPane.showMessageDialog(\r\n                        Application.getContext().getGui(),\r\n                        String.format(\"Value for parameter \\\"%s\\\" is not set, cancelling processing the Keep\",\r\n                                parameter.getName())\r\n                );\r\n                log.debug(\r\n                        \"The user probably clicked on the cancel button on the dialog to set a free-text for \"\r\n                                + \"the parameter [{}]\", parameter);\r\n                throw new KeepParameterExecutionException(\"User cancelled\");\r\n            } else {\r\n                if (keep.getPhrase() != null && !StringUtils.isEmpty(selectedParamValue)) {\r\n                    addParamValueToCurrentValues(parameter, currentParameterValuesMap, selectedParamValue);\r\n                    addParamValueToGlobalValues(parameter, selectedParamValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void addParamValueToCurrentValues(\r\n            KeepParameter parameter,\r\n            Map<String, String> currentParameterValuesMap,\r\n            String selectedParamValue) {\r\n        log.debug(\"Adding value of [{} for parameter [{}] to the current parameters values map\", selectedParamValue, parameter);\r\n        currentParameterValuesMap.put(parameter.getName(), selectedParamValue);\r\n    }\r\n\r\n    private static void addParamValueToGlobalValues(KeepParameter parameter, String selectedParamValue) {\r\n        if (parameter.isGlobal()) {\r\n            log.debug(\r\n                    \"As it is set to be global, adding value of [{}] for parameter [{}] to the global \"\r\n                            + \"parameters values map\", selectedParamValue, parameter);\r\n            GLOBAL_PARAMETER_VALUES_MAP.put(parameter.getName(), selectedParamValue);\r\n        }\r\n    }\r\n\r\n    private String displayParamValuesOptionsDialog(KeepParameter parameter, List<String> keepResult) {\r\n        String selectedParamValue;\r\n        log.debug(\"Showing the user a dialog to choose a value for tha parameter [{}]\", parameter);\r\n        selectedParamValue = (String) JOptionPane.showInputDialog(\r\n                Application.getContext().getGui().getContentPane(),\r\n                String.format(\"Choose a value for %s\", parameter.getName()),\r\n                \"Set parameter value\",\r\n                JOptionPane.QUESTION_MESSAGE,\r\n                null,\r\n                parseToLineByLine(keepResult),\r\n                null);\r\n        log.debug(\"User selected the value [{}] for parameter [{}]\", selectedParamValue, parameter);\r\n        if (StringUtils.isEmpty(selectedParamValue)) {\r\n            JOptionPane.showMessageDialog(\r\n                    Application.getContext().getGui(),\r\n                    String.format(\r\n                            \"Value for parameter \\\"%s\\\" is not set, cancelling processing the Keep\",\r\n                            parameter.getName())\r\n            );\r\n            log.debug(\r\n                    \"The user probably clicked on the cancel button on the dialog to choose a value \"\r\n                            + \"for the parameter [{}]\", parameter);\r\n            throw new KeepParameterExecutionException(\"User cancelled\");\r\n        }\r\n        return selectedParamValue;\r\n    }\r\n\r\n    private List<String> handleCommandTypeParamPhrase(KeepParameter parameter, Keep keep, Map<String, String> currentParameterValuesMap, boolean isRefreshGlobalParameters) {\r\n        List<String> keepResult = null;\r\n\r\n        if (!isFreeTextTypeParam(parameter)) {\r\n            try {\r\n                String paramKeepString = parameter.getPhrase();\r\n\r\n                log.debug(\"Parameter [{}] is of Command type, executing param command [{}]\", parameter, paramKeepString);\r\n                paramKeepString = populateParamPhraseWithAlreadySetParams(parameter, currentParameterValuesMap, paramKeepString);\r\n\r\n                // checking if the param Keep uses parameters as well, and if so, executing those first\r\n                for (KeepParameter innerParameter : keep.getParameters()) {\r\n                    if (paramKeepString.contains(String.format(\"<%s>\", innerParameter.getName()))) {\r\n                        // this parameter uses another one, so executing it first\r\n                        executeParameter(innerParameter, keep, isRefreshGlobalParameters, currentParameterValuesMap);\r\n                        paramKeepString = paramKeepString.replace(\r\n                                String.format(\"<%s>\", innerParameter.getName()),\r\n                                currentParameterValuesMap.get(innerParameter.getName()));\r\n                    }\r\n                }\r\n\r\n                keepResult = executeCommand(paramKeepString);\r\n                log.debug(\"Parameter [{}], Keep result=[{}]\", parameter, keepResult);\r\n            } catch (InterruptedException e) {\r\n                Thread.currentThread().interrupt();\r\n            } catch (Exception e) {\r\n                JOptionPane.showMessageDialog(\r\n                        Application.getContext().getGui().getContentPane(),\r\n                        String.format(\r\n                                \"Failed to run Keep \\\"%s\\\" for parameter \\\"%s\\\". %s.\",\r\n                                parameter.getPhrase(), parameter.getName(), e.getMessage()),\r\n                        \"Error when running a Keep\",\r\n                        JOptionPane.ERROR_MESSAGE\r\n                );\r\n            }\r\n        }\r\n        return keepResult;\r\n    }\r\n\r\n\r\n    private static String populateParamPhraseWithAlreadySetParams(KeepParameter parameter, Map<String, String> currentParameterValuesMap, String paramKeepString) {\r\n        // filling existing parameters values if already chosen and used in the next parameter\r\n        for (Map.Entry<String, String> currParam : currentParameterValuesMap.entrySet()) {\r\n            paramKeepString = paramKeepString.replace(String.format(\"<%s>\", currParam.getKey()), currParam.getValue());\r\n            log.debug(\"Parameter [{}] was taken from current run parameters, selected value=[{}]\", parameter, currParam.getValue());\r\n        }\r\n        return paramKeepString;\r\n    }\r\n\r\n    private static boolean isFreeTextTypeParam(KeepParameter parameter) {\r\n        return parameter.getPhrase() == null || parameter.getPhrase().isEmpty();\r\n    }\r\n\r\n    private static boolean ifParamValueSet(KeepParameter parameter, Map<String, String> currentParameterValuesMap) {\r\n        return currentParameterValuesMap.containsKey(parameter.getName());\r\n    }\r\n\r\n    private static void setParamValueFromGlobal(KeepParameter parameter, Map<String, String> currentParameterValuesMap) {\r\n        String selectedParamValue;\r\n        selectedParamValue = GLOBAL_PARAMETER_VALUES_MAP.get(parameter.getName());\r\n        currentParameterValuesMap.put(parameter.getName(), selectedParamValue);\r\n        log.debug(\"Parameter [{}] was taken from global parameters, selected value=[{}]\", parameter, selectedParamValue);\r\n    }\r\n\r\n    private static boolean isParamGlobalValueSet(KeepParameter parameter, boolean refreshParameters) {\r\n        return !refreshParameters && parameter.isGlobal() && GLOBAL_PARAMETER_VALUES_MAP.containsKey(parameter.getName());\r\n    }\r\n\r\n\r\n    /* ***************** PRIVATE METHODS ***************** */\r\n\r\n    private String manipulateParameters(Keep keep, boolean refreshParameters) {\r\n        log.debug(\"Manipulating parameters\");\r\n        // manipulating parameters\r\n\r\n        String keepToExecute = keep.getPhrase();\r\n        Map<String, String> currentParameterValuesMap = new HashMap<>();\r\n        if (keep.getParameters() != null && !keep.getParameters().isEmpty()) {\r\n            for (KeepParameter parameter : keep.getParameters()) {\r\n                log.debug(\"Manipulating parameter [{}]\", parameter);\r\n\r\n                try {\r\n                    executeParameter(parameter, keep, refreshParameters, currentParameterValuesMap);\r\n                } catch (KeepParameterExecutionException ex) {\r\n                    log.error(FAILED_TO_EXECUTE_KEEP, ex);\r\n                    return null; // cancelling\r\n                }\r\n            }\r\n\r\n            for (Map.Entry<String, String> entry : currentParameterValuesMap.entrySet()) {\r\n                keepToExecute = keepToExecute.replace(String.format(\"<%s>\", entry.getKey()), entry.getValue());\r\n            }\r\n        }\r\n\r\n        return keepToExecute;\r\n    }\r\n\r\n    private String[] parseToLineByLine(List<String> stringToParse) {\r\n        if (stringToParse.size() == 1 && stringToParse.get(0).startsWith(\"[\") && stringToParse.get(0).endsWith(\"]\")) {\r\n            // this is a one-liner json array, splitting it, the next 'if' statement will process it\r\n            String jsonArr = stringToParse.get(0);\r\n            jsonArr = jsonArr.substring(1, jsonArr.length() - 1);\r\n            stringToParse = Arrays.asList(jsonArr.split(\",\"));\r\n        }\r\n\r\n        if (!stringToParse.isEmpty() && stringToParse.get(0).equals(\"[\")) {\r\n            // in case of a json array, an option to return visible and actual values for the dropdown lists (name of ec2\r\n            // instance to display, the id to use on the command)\r\n            // parse from a json array\r\n            stringToParse.remove(0); // the opening '['\r\n            stringToParse.remove(stringToParse.size() - 1); // the closing ']'\r\n            stringToParse.replaceAll(s -> s.replace(\"\\\",\", \"\").replace(\"\\\"\", \"\").trim()); // removing \", and \"\r\n        }\r\n\r\n        Collections.sort(stringToParse);\r\n\r\n        return stringToParse.toArray(new String[stringToParse.size()]);\r\n    }\r\n\r\n    private void handleOnlyCopy() {\r\n        new Thread(() -> {\r\n            Application.getContext().getGui().labelTargetWindow.setText(\"Keep copied, ready to paste...\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(2);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"Sleep interrupted exception\", e);\r\n                Thread.currentThread().interrupt();\r\n            }\r\n            Application.getContext().getGui().labelTargetWindow.setText(ONLY_COPY_MODE);\r\n        }).start();\r\n    }\r\n\r\n    private void validateValueSetForGlobalParam(KeepParameter parameter,\r\n                                                Map<String, String> currentParameterValuesMap,\r\n                                                boolean refreshParameters) {\r\n        // checking if we already have a value for this parameter on the global parameters (unless refresh parameters was chosen)\r\n        if (isParamGlobalValueSet(parameter, refreshParameters)) {\r\n            setParamValueFromGlobal(parameter, currentParameterValuesMap);\r\n        }\r\n    }\r\n\r\n    private List<String> handleArrayTypeParamPhrase(KeepParameter parameter) {\r\n        List<String> keepResult = null;\r\n        if (!isFreeTextTypeParam(parameter) && parameter.getPhrase().startsWith(\"[\")) {\r\n            // predefined array of values\r\n            keepResult = Arrays.stream(parameter.getPhrase().substring(1, parameter.getPhrase().length() - 1)\r\n                            .split(\",\")).map(String::trim)\r\n                    .collect(Collectors.toList());\r\n            log.debug(\"Parameter [{}] is of array type, values=[{}]\", parameter, keepResult);\r\n        }\r\n        return keepResult;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java b/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java
--- a/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java	(revision 2f3a4c4b47e0711d04fd9b73994bd1daab9f3eee)
+++ b/logic/src/main/java/com/keepaste/logic/managers/KeepExecutionManager.java	(date 1698616043793)
@@ -60,6 +60,9 @@
                 }
             } catch (Exception ex) {
                 log.error(String.format("Failed to get shell, using default shell of [%s]", shell), ex);
+                if (ex instanceof InterruptedException) {
+                    Thread.currentThread().interrupt();
+                }
             }
         }
     }
@@ -119,34 +122,23 @@
         SwingWorker<Void, String> worker = new SwingWorker<>() {
             @Override
             protected Void doInBackground() {
-//                try {
-                    String keepToExecute = manipulateParameters(keep, refreshParameters);
-                    log.info("Final Keep to execute [{}]", keepToExecute);
-                    if (!StringUtils.isEmpty(keepToExecute)) {
+                String keepToExecute = manipulateParameters(keep, refreshParameters);
+                log.info("Final Keep to execute [{}]", keepToExecute);
+                if (!StringUtils.isEmpty(keepToExecute)) {
 
-                        copyToClipboard(keepToExecute);
+                    copyToClipboard(keepToExecute);
 
-                        if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
-                            handleOnlyCopy();
-                        } else {
-                            if (isFocusOnActiveWindow(currentlyActiveWindow)) {
-                                pasteKeep();
-                                pressEnter(keep);
-                            } else {
-                                handleWrongTargetWindow();
-                            }
-                        }
-                    }
-//                }
-
-//                catch (Exception e) {
-//                    JOptionPane.showMessageDialog(Application.getContext().getGui(),
-//                            FAILED_TO_EXECUTE_KEEP,
-//                            "Bummer...",
-//                            JOptionPane.ERROR_MESSAGE);
-//                    log.error(FAILED_TO_EXECUTE_KEEP, e);
-//                    throw e;
-//                }
+                    if (!Application.getContext().getModelSettings().isFocusOnWindowAndPaste()) {
+                        handleOnlyCopy();
+                    } else {
+                        if (isFocusOnActiveWindow(currentlyActiveWindow)) {
+                            pasteKeep();
+                            pressEnter(keep);
+                        } else {
+                            handleWrongTargetWindow();
+                        }
+                    }
+                }
                 return null;
             }
 
@@ -239,12 +231,14 @@
      * Will execute a command in shell and return its output as a list of Strings.
      *
      * @param commandLines  the command lines to execute
-     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal commands (like intercepting the currently active window)
+     * @param defaultPath   will use the default PATH env var and not the one set by the user, used for Keepaste internal
+     *                      commands (like intercepting the currently active window)
      * @return  the execution output
      * @throws IOException in case of execution failure
      * @throws InterruptedException in case of execution failure
      */
-    public List<String> executeCommand(List<String> commandLines, boolean defaultPath) throws KeepExecutionException, IOException, InterruptedException {
+    public List<String> executeCommand(List<String> commandLines, boolean defaultPath)
+            throws KeepExecutionException, IOException, InterruptedException {
         ProcessBuilder processBuilder = new ProcessBuilder();
         // Set the working directory for the process
         processBuilder.directory(new File(FileSystemUtils.getUserHomeDirectory()));
@@ -411,7 +405,8 @@
         return selectedParamValue;
     }
 
-    private List<String> handleCommandTypeParamPhrase(KeepParameter parameter, Keep keep, Map<String, String> currentParameterValuesMap, boolean isRefreshGlobalParameters) {
+    private List<String> handleCommandTypeParamPhrase(
+            KeepParameter parameter, Keep keep, Map<String, String> currentParameterValuesMap, boolean isRefreshGlobalParameters) {
         List<String> keepResult = null;
 
         if (!isFreeTextTypeParam(parameter)) {
@@ -451,7 +446,8 @@
     }
 
 
-    private static String populateParamPhraseWithAlreadySetParams(KeepParameter parameter, Map<String, String> currentParameterValuesMap, String paramKeepString) {
+    private static String populateParamPhraseWithAlreadySetParams(
+            KeepParameter parameter, Map<String, String> currentParameterValuesMap, String paramKeepString) {
         // filling existing parameters values if already chosen and used in the next parameter
         for (Map.Entry<String, String> currParam : currentParameterValuesMap.entrySet()) {
             paramKeepString = paramKeepString.replace(String.format("<%s>", currParam.getKey()), currParam.getValue());
Index: logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.managers.window;\r\n\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.managers.KeepsManager;\r\nimport com.keepaste.logic.models.WindowInformation;\r\nimport com.keepaste.logic.utils.FileSystemUtils;\r\nimport com.keepaste.logic.utils.KeyboardUtils;\r\nimport lombok.NonNull;\r\nimport lombok.extern.log4j.Log4j2;\r\nimport java.io.File;\r\nimport java.io.FileWriter;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * This class is Mac's {@link WindowManager}, it holds relevant methods related to windows management in Mac's OS's.\r\n */\r\n@Log4j2\r\npublic final class MacWindowsManager implements WindowManager {\r\n    public static final String GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME = \"GetTopMostWindow.applescript\";\r\n    public static final int GET_ACTIVE_WINDOW_NUM_TRIES = 3;\r\n    public static final int SLEEP_INTERVAL_BETWEEN_RETRIES = 150;\r\n    public static final int SLEEP_AFTER_PASTE_IN_MS = 50;\r\n    private String lastTopMostWindowResult;\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    public MacWindowsManager() {\r\n        delAppleScriptFilesForRefresh();\r\n    }\r\n\r\n    @Override\r\n    public WindowInformation getActiveWindow() {\r\n        String topMostWindowResult = null;\r\n        try {\r\n            int tries = GET_ACTIVE_WINDOW_NUM_TRIES;\r\n            do {\r\n                topMostWindowResult = runAppleScriptFile(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME);\r\n\r\n                if (topMostWindowResult != null && !topMostWindowResult.equals(lastTopMostWindowResult)) {\r\n                    if (!topMostWindowResult.startsWith(\"success\")) {\r\n                        log.error(topMostWindowResult);\r\n                    } else {\r\n                        log.debug(\"top most window = [{}]\", topMostWindowResult);\r\n                        lastTopMostWindowResult = topMostWindowResult;\r\n                        topMostWindowResult = topMostWindowResult.replace(\"}\", \"\");\r\n                        topMostWindowResult = topMostWindowResult.replace(\"{\", \"\");\r\n                        topMostWindowResult = topMostWindowResult.replace(\" \", \"\");\r\n                        String[] activeWindowSegments = topMostWindowResult.split(\",\");\r\n                        String text = activeWindowSegments[2];\r\n                        String app = activeWindowSegments[1];\r\n                        return WindowInformation.builder()\r\n                                .text(text)\r\n                                .app(app)\r\n                                .top(0)\r\n                                .bottom(0)\r\n                                .left(0)\r\n                                .right(0)\r\n                                .processId(Integer.parseInt(activeWindowSegments[GET_ACTIVE_WINDOW_NUM_TRIES]))\r\n                                .build();\r\n\r\n                    }\r\n                    lastTopMostWindowResult = topMostWindowResult;\r\n                }\r\n                TimeUnit.MILLISECONDS.sleep(SLEEP_INTERVAL_BETWEEN_RETRIES);\r\n                tries--;\r\n            } while (tries > 0);\r\n        } catch (InterruptedException ex) {\r\n            // Restore interrupted state...\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception ex) {\r\n            log.debug(String.format(\"Failed to get active window, top most window=[%s]\",\r\n                    topMostWindowResult == null ? \"null\" : topMostWindowResult), ex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void paste() {\r\n        log.debug(\"Pasting using osascript for CMD+V (Apple)\");\r\n        try {\r\n            // this is commented out as it doesn't work well when the command is on one language (English) and the\r\n            // operating system input is set to be in another language (such as Hebrew)\r\n            // so shifted to use cmd+V\r\n            //            Application.getContext().getKeepExecutionManager().executeCommand(\r\n            //            \"osascript -e'tell application \\\"System Events\\\" to keystroke \\\"v\\\" using command down'\");\r\n            cmdV();\r\n            TimeUnit.MILLISECONDS.sleep(SLEEP_AFTER_PASTE_IN_MS);\r\n//        } catch (IOException e) {\r\n//            log.error(\"Failed to paste for mac\", e);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to paste on Mac\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean focusOnActiveWindow(@NonNull final WindowInformation windowContext) {\r\n        try {\r\n            log.debug(\"Switching to next window\");\r\n            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(\"osascript -e 'tell application \\\"System Events\\\" to key code 118 using control down'\");\r\n            // validating that the window is the desired one\r\n            return Application.getContext().getModelActiveWindow().getActiveWindow().equals(windowContext);\r\n        } catch (InterruptedException e) {\r\n            log.error(String.format(\"Failed to focus on window [%s]\", windowContext), e);\r\n            Thread.currentThread().interrupt();\r\n            return false;\r\n        } catch (Exception e) {\r\n            log.error(String.format(\"Failed to focus on window [%s]\", windowContext), e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Runs applescript files.\r\n     *\r\n     * @param filename      the filename of the applescript file\r\n     * @param params       relevant command parameters\r\n     * @return             the output as a String\r\n     */\r\n    public String runAppleScriptFile(String filename, String... params) {\r\n        try {\r\n            String filePath = FileSystemUtils.getKeepasteDirectory().concat(\"/\").concat(filename);\r\n            File scriptFile = new File(filePath);\r\n            if (!scriptFile.exists()) {\r\n                try (InputStream inputStream = KeepsManager.class.getResourceAsStream(\"/scripts/mac/\".concat(filename))) {\r\n                    if (inputStream != null) {\r\n                        String fileContents = new String(inputStream.readAllBytes());\r\n                        try (FileWriter writer = new FileWriter(filePath)) {\r\n                            log.info(\"Saved \".concat(filePath));\r\n                            writer.write(fileContents);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            String command = \"osascript \".concat(scriptFile.getAbsolutePath());\r\n\r\n            for (String param : params) {\r\n                command = command.concat(\" \\\"\").concat(param).concat(\"\\\"\");\r\n            }\r\n\r\n            List<String> output = Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(command);\r\n            if (!output.isEmpty()) {\r\n                return output.get(0);\r\n            }\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        } catch (Exception e) {\r\n            log.error(String.format(\"Failed to run apple script file [%s]\", filename), e);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will delete the used applescript files from the .keepaste folder in order to keep those refreshed, if any changes\r\n     * were done to them between versions.\r\n     */\r\n    private void delAppleScriptFilesForRefresh() {\r\n        FileSystemUtils.deleteFile(FileSystemUtils.getKeepasteDirectory().concat(\"/\").concat(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME));\r\n    }\r\n\r\n    /**\r\n     * imitating a cmd+v press for pasting on Mac.\r\n     */\r\n    private void cmdV() {\r\n        log.debug(\"Robot pressing CMD+V (pasting on mac)\");\r\n        KeyboardUtils.cmdV();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java b/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java
--- a/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java	(revision 2f3a4c4b47e0711d04fd9b73994bd1daab9f3eee)
+++ b/logic/src/main/java/com/keepaste/logic/managers/window/MacWindowsManager.java	(date 1698616043789)
@@ -99,15 +99,9 @@
     public void paste() {
         log.debug("Pasting using osascript for CMD+V (Apple)");
         try {
-            // this is commented out as it doesn't work well when the command is on one language (English) and the
-            // operating system input is set to be in another language (such as Hebrew)
-            // so shifted to use cmd+V
-            //            Application.getContext().getKeepExecutionManager().executeCommand(
-            //            "osascript -e'tell application \"System Events\" to keystroke \"v\" using command down'");
-            cmdV();
+            Application.getContext().getKeepExecutionManager().executeCommand(
+                    "osascript -e 'tell application \"System Events\" to key code {9} using command down'");
             TimeUnit.MILLISECONDS.sleep(SLEEP_AFTER_PASTE_IN_MS);
-//        } catch (IOException e) {
-//            log.error("Failed to paste for mac", e);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
         } catch (Exception e) {
@@ -119,7 +113,8 @@
     public boolean focusOnActiveWindow(@NonNull final WindowInformation windowContext) {
         try {
             log.debug("Switching to next window");
-            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath("osascript -e 'tell application \"System Events\" to key code 118 using control down'");
+            Application.getContext().getKeepExecutionManager().executeCommandWithDefaultPath(
+                    "osascript -e 'tell application \"System Events\" to key code 118 using control down'");
             // validating that the window is the desired one
             return Application.getContext().getModelActiveWindow().getActiveWindow().equals(windowContext);
         } catch (InterruptedException e) {
@@ -182,11 +177,4 @@
         FileSystemUtils.deleteFile(FileSystemUtils.getKeepasteDirectory().concat("/").concat(GET_TOP_MOST_WINDOW_APPLESCRIPT_FILENAME));
     }
 
-    /**
-     * imitating a cmd+v press for pasting on Mac.
-     */
-    private void cmdV() {
-        log.debug("Robot pressing CMD+V (pasting on mac)");
-        KeyboardUtils.cmdV();
-    }
 }
Index: logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Keepaste - The keep and paste program (http://www.keepaste.com)\r\n * Copyright (C) 2023 Tamir Krispis\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npackage com.keepaste.logic.views;\r\n\r\nimport com.keepaste.gui.DialogKeep;\r\nimport com.keepaste.logic.Application;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.AddParamActionListener;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.ExistingParamActionListener;\r\nimport com.keepaste.logic.actionlisteners.dialogkeep.RemoveParamActionListener;\r\nimport com.keepaste.logic.models.Keep;\r\nimport com.keepaste.logic.models.KeepsGroup;\r\nimport com.keepaste.logic.models.KeepParameter;\r\nimport com.keepaste.logic.utils.GuiUtils;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport javax.swing.*;\r\nimport javax.swing.table.TableCellEditor;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * This View class manages the {@link DialogKeep}.\r\n */\r\npublic class ViewDialogKeep {\r\n    private final DialogKeep dialogKeep = new DialogKeep(Application.getContext().getGui(), true);\r\n    private final List<KeepParameter> editedParameters;\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param keep      the {@link Keep} in context\r\n     */\r\n    public ViewDialogKeep(final Keep keep) {\r\n        dialogKeep.setAlwaysOnTop(true);\r\n        dialogKeep.setModal(true);\r\n\r\n        dialogKeep.setLocationRelativeTo(Application.getContext().getGui());\r\n\r\n        dialogKeep.textName.setText(keep.getTitle());\r\n        dialogKeep.textKeep.setText(keep.getPhrase());\r\n        dialogKeep.textDescription.setText(keep.getDescription());\r\n\r\n        // parameters\r\n        this.editedParameters = keep.getParameters() == null ? new ArrayList<>() : new ArrayList<>(keep.getParameters());\r\n        dialogKeep.tableParams.setModel(getTableModel());\r\n\r\n        dialogKeep.buttonAddParam.addActionListener(new AddParamActionListener(dialogKeep.tableParams));\r\n        dialogKeep.buttonRemoveParam.addActionListener(new RemoveParamActionListener(dialogKeep.tableParams));\r\n        dialogKeep.buttonExistingParam.addActionListener(new ExistingParamActionListener(dialogKeep));\r\n\r\n        dialogKeep.buttonCancel.addActionListener(e -> dialogKeep.setVisible(false));\r\n\r\n        dialogKeep.buttonOK.addActionListener(e -> {\r\n            if (dialogKeep.tableParams.isEditing()) {\r\n                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());\r\n                if (cellEditor != null) {\r\n                    cellEditor.stopCellEditing();\r\n                }\r\n            }\r\n            if (StringUtils.isEmpty(dialogKeep.textKeep.getText()) || StringUtils.isEmpty(dialogKeep.textName.getText())) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"Both Name and Keep fields are mandatory\", \"Not enough...\", JOptionPane.ERROR_MESSAGE);\r\n                return;\r\n            }\r\n            // validating that there are no duplications in parameter names\r\n            if (editedParameters.stream().map(KeepParameter::getName).distinct().count() < editedParameters.size()) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"There are duplications in parameters names, please review\");\r\n                return;\r\n            }\r\n\r\n            // validating that all command parameters are met\r\n            String commandStr = dialogKeep.textKeep.getText();\r\n            for (KeepParameter parameter : editedParameters) {\r\n                commandStr = commandStr.replace(String.format(\"<%s>\", parameter.getName()), \"\");\r\n            }\r\n            if (commandStr.contains(\"<\") && commandStr.contains(\">\")) {\r\n                JOptionPane.showMessageDialog(Application.getContext().getGui(), \"Given parameters does not cover all keep parameters, please add missing ones\");\r\n                return;\r\n            }\r\n\r\n            // also for parameters\r\n            for (KeepParameter parameter : editedParameters) {\r\n                String parameterPhrase = parameter.getPhrase();\r\n                for (KeepParameter otherParameters : editedParameters) {\r\n                    if (otherParameters == parameter) {\r\n                        // validating that a keep parameter doesn't reference itself\r\n                        if (parameterPhrase.contains(String.format(\"<%s>\", parameter.getName()))) {\r\n                            JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format(\"The parameter %s cannot use its own name as a command parameter.\", parameter.getName()));\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        parameterPhrase = parameterPhrase.replace(String.format(\"<%s>\", otherParameters.getName()), \"\");\r\n                    }\r\n                }\r\n                int startIndex = parameterPhrase.indexOf(\"<\");\r\n                int endIndex = parameterPhrase.indexOf(\">\", startIndex);\r\n                if (startIndex > 0 && endIndex > 0) {\r\n                    String missingParamName = parameterPhrase.substring(startIndex + 1, endIndex);\r\n                    JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format(\"Given parameters does not cover all used parameters (on keep or its parameters), please add the following missing parameter - %s\", missingParamName));\r\n                    return;\r\n                }\r\n            }\r\n\r\n            keep.setTitle(dialogKeep.textName.getText().trim());\r\n            keep.setPhrase(dialogKeep.textKeep.getText().trim());\r\n            keep.setDescription(dialogKeep.textDescription.getText().trim());\r\n            keep.setNeverPressEnter(dialogKeep.checkNeverPressEnter.isSelected());\r\n            // getting parameters\r\n            keep.setParameters(editedParameters);\r\n            KeepsGroup rootNode = Application.getContext().getKeepsManager().getRootNode();\r\n            Application.getContext().getKeepsManager().saveKeeps(rootNode);\r\n            dialogKeep.setVisible(false);\r\n        });\r\n        GuiUtils.showDialogOnCenterScreen(dialogKeep);\r\n    }\r\n\r\n    private KeepParametersTableModel getTableModel() {\r\n        return new KeepParametersTableModel(editedParameters);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java b/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java
--- a/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java	(revision 2f3a4c4b47e0711d04fd9b73994bd1daab9f3eee)
+++ b/logic/src/main/java/com/keepaste/logic/views/ViewDialogKeep.java	(date 1698615901660)
@@ -54,6 +54,7 @@
         dialogKeep.textName.setText(keep.getTitle());
         dialogKeep.textKeep.setText(keep.getPhrase());
         dialogKeep.textDescription.setText(keep.getDescription());
+        dialogKeep.checkNeverPressEnter.setSelected(keep.isNeverPressEnter());
 
         // parameters
         this.editedParameters = keep.getParameters() == null ? new ArrayList<>() : new ArrayList<>(keep.getParameters());
@@ -67,18 +68,21 @@
 
         dialogKeep.buttonOK.addActionListener(e -> {
             if (dialogKeep.tableParams.isEditing()) {
-                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());
+                TableCellEditor cellEditor = dialogKeep.tableParams.getCellEditor(
+                        dialogKeep.tableParams.getEditingRow(), dialogKeep.tableParams.getEditingColumn());
                 if (cellEditor != null) {
                     cellEditor.stopCellEditing();
                 }
             }
             if (StringUtils.isEmpty(dialogKeep.textKeep.getText()) || StringUtils.isEmpty(dialogKeep.textName.getText())) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "Both Name and Keep fields are mandatory", "Not enough...", JOptionPane.ERROR_MESSAGE);
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "Both Name and Keep fields are mandatory", "Not enough...", JOptionPane.ERROR_MESSAGE);
                 return;
             }
             // validating that there are no duplications in parameter names
             if (editedParameters.stream().map(KeepParameter::getName).distinct().count() < editedParameters.size()) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "There are duplications in parameters names, please review");
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "There are duplications in parameters names, please review");
                 return;
             }
 
@@ -88,7 +92,8 @@
                 commandStr = commandStr.replace(String.format("<%s>", parameter.getName()), "");
             }
             if (commandStr.contains("<") && commandStr.contains(">")) {
-                JOptionPane.showMessageDialog(Application.getContext().getGui(), "Given parameters does not cover all keep parameters, please add missing ones");
+                JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                        "Given parameters does not cover all keep parameters, please add missing ones");
                 return;
             }
 
@@ -99,7 +104,8 @@
                     if (otherParameters == parameter) {
                         // validating that a keep parameter doesn't reference itself
                         if (parameterPhrase.contains(String.format("<%s>", parameter.getName()))) {
-                            JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format("The parameter %s cannot use its own name as a command parameter.", parameter.getName()));
+                            JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                                    String.format("The parameter %s cannot use its own name as a command parameter.", parameter.getName()));
                             return;
                         }
                     } else {
@@ -110,7 +116,9 @@
                 int endIndex = parameterPhrase.indexOf(">", startIndex);
                 if (startIndex > 0 && endIndex > 0) {
                     String missingParamName = parameterPhrase.substring(startIndex + 1, endIndex);
-                    JOptionPane.showMessageDialog(Application.getContext().getGui(), String.format("Given parameters does not cover all used parameters (on keep or its parameters), please add the following missing parameter - %s", missingParamName));
+                    JOptionPane.showMessageDialog(Application.getContext().getGui(),
+                            String.format("Given parameters does not cover all used parameters (on keep or its parameters),"
+                                    + " please add the following missing parameter - %s", missingParamName));
                     return;
                 }
             }
